<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="stylesheet" href="css/leaflet.css">
        <link rel="stylesheet" href="css/fontawesome-all.min.css">
        <link rel="stylesheet" href="css/leaflet-measure.css">
        <link rel="stylesheet" href="css/leaflet-control-geocoder.Geocoder.css">
        <link rel="stylesheet" href="css/leaflet.draw.css">
        <!-- jQuery primeiro -->
        <script src="js/jquery.min.js"></script>

        <!-- Spectrum CSS -->
        <link rel="stylesheet" type="text/css" href="css/spectrum.min.css" />

        <!-- Spectrum JS -->
        <script src="js/spectrum.min.js"></script>

        <!-- Omnivore para leitura de KML -->
        <script src='js/leaflet-omnivore.min.js'></script>

        <!-- Font Awesome -->
        <!--<link rel="stylesheet" href="css/all.min.css">

<!-- Gráfico de linha topográfica -->
        <script src="js/chart.js"></script>

        <!-- html2canvas -->
        <script src="js/html2canvas.min.js"></script>

        <!-- Edição de textos -->
        <script src="js/tinymce/tinymce.min.js" referrerpolicy="origin"></script>


        <!-- SweetAlert2 CSS -->
        <link rel="stylesheet" href="css/sweetalert2.min.css">

        <!-- Inclua o CSS do Leaflet Control Geocoder -->
        <link rel="stylesheet" href="css/Control.Geocoder.css" />
        
        <script type="text/javascript">
            function googleTranslateElementInit() {
                new google.translate.TranslateElement({
                    pageLanguage: 'pt-br'
                }, 'google_translate_element');
            }
        </script>
        <script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>















        <style>
            #map {
                width: 100%;
                height: 90vh; /* 80% da altura da janela de visualização */
                min-height: 500px; /* Altura mínima para garantir usabilidade */
            }
            #elevation-profile-canvas {
                border: 2px solid #000; /* Define uma borda sólida preta com 2px de espessura */
                display:none;
            }
            .color-picker {
                position: absolute;
                top: 10px;
                left: 10px;
                z-index: 1000;
            }
            .map-toolbar {
                background-color: #f8f9fa;
                padding: 10px;
                color: #333;
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                justify-content: space-between;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }

            .toolbar-item label,
            .color-picker-label label {
                margin-right: 3px;
                font-weight: bold;
            }

            .toolbar-button,
            .toolbar-item {
                margin: 3px;
                background-color: #e7e7e7;
                border: 1px solid #ccc;
                padding: 8px;
                border-radius: 5px;
                color: #333;
                cursor: pointer;
                display: flex;
                align-items: center;
                flex: 1 1 auto; /* Permite que os itens se ajustem */
                min-width: 80px; /* Largura mínima para botões */
                box-sizing: border-box; /* Inclui padding e borda na largura */
            }

            .toolbar-button:hover,
            .toolbar-item select:hover,
            #transparencySlider:hover {
                background-color: #d6d6d6;
            }

            #colorPicker {
                padding: 5px;
                border-radius: 5px;
                border: 1px solid #ccc;
                cursor: pointer;
                width: auto;
            }

            .toolbar-item select,
            #transparencySlider {
                background-color: #fff;
                color: #333;
                border: 1px solid #ccc;
                padding: 5px;
                border-radius: 5px;
                max-width: 100%; /* Não excede a largura do contêiner */
                width: 100%; /* Ocupa toda a largura disponível */
                box-sizing: border-box; /* Inclui padding e borda na largura */
                overflow: hidden; /* Oculta conteúdo que excede a largura */
                text-overflow: ellipsis; /* Adiciona reticências se o texto for muito longo */
                white-space: nowrap; /* Impede quebra de linha */
            }

            .toolbar-button i {
                margin-right: 5px;
            }
            .toolbar-icons {
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            .toolbar-icon {
                margin: 0 10px;
                cursor: pointer;
            }

            .toolbar-icon:hover {
                color: #007bff; /* Cor de destaque ao passar o mouse */
            }
            /* Estilos padrão para desktop */
            .toolbar-item select,
            .toolbar-item input[type='range'],
            .toolbar-icons i {
                font-size: 16px; /* Tamanho padrão da fonte */
            }

            .toolbar-icons i {
                margin: 0 10px; /* Espaçamento padrão */
                cursor: pointer;
            }

            @media (min-width: 601px) {
                .toggle-controls {
                    display: none; /* Ocultar botão em dispositivos não móveis */
                }
            }

            #close-btn {
                padding: 5px 10px;
                cursor: pointer;
                background-color: red;
                color: white;
                border: none;
                border-radius: 5px;
            }
            /* Estilos para o conteúdo do popup */
            .popup-content {
                max-height: 400px;
                overflow-y: auto;
            }

            /* Estilos opcionais para o popup personalizado */
            .custom-popup .leaflet-popup-content-wrapper {
                scroll-behavior: smooth;
            }

            .custom-popup .leaflet-popup-content {
                padding: 10px;
            }






            #iconSelectorContainer {
                position: relative;
            }

            #iconSelectorToggle {
                padding: 10px;
                cursor: pointer;
                background-color: #007bff;
                color: #ffffff;
                border: none;
                border-radius: 4px;
            }

            #iconSelectorToggle:hover {
                background-color: #0056b3;
            }

            #iconSelectorContent {
                /* Suas outras propriedades existentes */
                position: absolute;
                z-index: 1000;
                background-color: #ffffff;
                border: 1px solid #ccc;
                padding: 10px;
                max-height: 300px;
                overflow-y: auto;
                width: 400px;

                /* Adicione ou altere estas propriedades */
                bottom: 100%;
                left: 0;
            }


            .folder-list {
                display: flex;
                flex-wrap: wrap;
                margin-bottom: 10px;
            }

            .folder-button {
                margin: 5px;
                padding: 10px;
                cursor: pointer;
                background-color: #f0f0f0;
                border: none;
                border-radius: 4px;
            }

            .folder-button:hover {
                background-color: #e0e0e0;
            }

            .icon-list {
                display: flex;
                flex-wrap: wrap;
            }

            .icon-item {
                margin: 5px;
                text-align: center;
            }

            .icon-image {
                width: 40px;
                height: 40px;
                cursor: pointer;
            }

            .icon-image:hover {
                transform: scale(1.1);
            }

            #iconPreview {
                width: 40px;
                height: 40px;
            }


            @media (max-width: 600px) {
                /* Ajustes no Mapa */
                #map {
                    width: 100%;
                    height: 90vh;
                    min-height: 500px;
                    touch-action: none;
                }

                /* Botões de Confirmação e Cancelamento do SweetAlert2 */
                .swal2-confirm,
                .swal2-cancel {
                    font-size: 10px;
                    padding: 6px 12px;
                    max-width: 100px;
                    min-width: 80px;
                }

                /* Ações do SweetAlert2 */
                .swal2-actions {
                    flex-wrap: nowrap;
                    overflow-x: auto;
                    gap: 5px;
                }

                /* Estilização da Barra de Rolagem das Ações do SweetAlert2 */
                .swal2-actions::-webkit-scrollbar {
                    height: 6px;
                }

                .swal2-actions::-webkit-scrollbar-thumb {
                    background-color: rgba(0, 0, 0, 0.2);
                    border-radius: 3px;
                }

                /* Itens da Barra de Ferramentas e Ícones */
                .toolbar-item select,
                .toolbar-item input[type='range'],
                .toolbar-icons i {
                    font-size: 12px;
                }

                .toolbar-icons i {
                    margin: 0 3px;
                }

                /* Botões e Itens da Barra de Ferramentas */
                .toolbar-button,
                .toolbar-item {
                    padding: 5px;
                    font-size: 12px;
                    flex: 1 1 45%;
                    min-width: 100px;
                    margin: 2px;
                    box-sizing: border-box;
                    white-space: nowrap;
                }

                /* Barra de Ferramentas do Mapa */
                .map-toolbar {
                    background-color: #f8f9fa;
                    padding: 5px;
                    color: #333;
                    display: flex;
                    flex-wrap: wrap;
                    align-items: center;
                    justify-content: flex-start;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                    width: 100%;
                    box-sizing: border-box;
                    margin-right: 10px;
                    max-width: calc(100% - 20px);
                }

                /* Seletores e Slider de Transparência na Barra de Ferramentas */
                .toolbar-item select,
                #transparencySlider {
                    font-size: 12px;
                    padding: 5px;
                    max-width: 90%;
                    width: 90%;
                    box-sizing: border-box;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }

                /* Labels nos Itens da Barra de Ferramentas */
                .toolbar-item label {
                    font-size: 12px;
                    margin: 3px;
                    white-space: nowrap;
                }



                /* Ícones nos Botões e Itens da Barra de Ferramentas */
                .toolbar-button i,
                .toolbar-item i {
                    margin: 3px 3px;
                }

                /* Canvas do Perfil de Elevação */
                #elevation-profile-canvas {
                    width: 100%;
                    height: 200px;
                }

                /* Botão para Alternar Controles em Dispositivos Móveis */
                .toggle-controls {
                    display: block;
                    position: fixed;
                    bottom: 10px;
                    right: 10px;
                    z-index: 2000;
                    padding: 10px;
                    background-color: #007bff;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                }

                /* Ferramentas do Leaflet */
                .leaflet-draw-toolbar {
                    display: block;
                }

                .leaflet-control-browser-print {
                    display: none !important;
                }

                /* Seletor de Camadas */
                #layerSelector {
                    display: block !important;
                }

                /* Botões de Pasta */
                .folder-button {
                    margin: 3px;
                    padding: 5px;
                    font-size: 12px;
                    flex: 1 1 45%;
                }



                .icon-image {
                    width: 30px !important;        /* Reduz o tamanho das imagens dos ícones */
                    height: 30px !important;
                }


                /* Popup do SweetAlert2 */
                .swal2-popup {
                    width: 90% !important;
                    max-width: 100% !important;
                    box-sizing: border-box;
                    overflow-x: hidden;
                }

                .swal2-popup select {
                    width: 100% !important;
                    box-sizing: border-box;
                    max-width: 100% !important;
                    overflow: hidden;
                    white-space: nowrap;
                    text-overflow: ellipsis;
                }

                /* Botões de Sequência */
                #saveSequenceButton,
                #loadSequenceButton,
                #executeSequenceButton,
                #deleteSequenceButton {
                    display: block !important;
                    flex: none !important;
                    width: 100% !important;
                    margin: 5px 0 !important;
                    box-sizing: border-box;
                }

                /* Container Flex do Popup do SweetAlert2 */
                .swal2-popup div[style*="display: flex"][style*="justify-content: space-between"] {
                    flex-direction: column !important;
                    align-items: stretch !important;
                    margin-top: 10px !important;
                }

                /* Ícones nos Botões de Sequência */
                #saveSequenceButton i,
                #loadSequenceButton i,
                #executeSequenceButton i,
                #deleteSequenceButton i {
                    margin-right: 5px !important;
                }
                /* Ajustes para os inputs do SweetAlert2 */
                .swal2-popup .swal2-input {
                    width: 90% !important;           /* Garante que o input ocupe toda a largura disponível */
                    box-sizing: border-box;           /* Inclui padding e border no cálculo da largura */
                    margin: 5px 5px;                    /* Adiciona margem vertical para espaçamento entre os inputs */
                }

                /* Opcional: Limitar a altura do modal e permitir rolagem vertical */
                .swal2-popup {
                    max-height: 90vh !important;      /* Limita a altura máxima do modal a 90% da viewport */
                    overflow-y: auto !important;      /* Adiciona rolagem vertical se necessário */
                }

                /* Ajustes para o select do SweetAlert2 */
                .swal2-popup .swal2-select {
                    width: 90% !important;           /* Garante que o select ocupe toda a largura disponível */
                    box-sizing: border-box;           /* Inclui padding e border no cálculo da largura */
                    margin: 5px 5px;                    /* Adiciona margem vertical para espaçamento */
                    font-size: 14px;                  /* Ajusta o tamanho da fonte para melhor legibilidade */
                }
                /* Opcional: Ajustar o título do modal para melhor adaptação */
                .swal2-popup .swal2-title {
                    font-size: 18px;                   /* Reduz o tamanho da fonte do título */
                    text-align: center;                /* Centraliza o título */
                    margin-bottom: 15px;                /* Adiciona margem inferior para espaçamento */
                }



                /* Ajustes para o container do seletor de ícones */
                #iconSelectorContent {
                    width: 100%;
                    max-height: 50vh;
                    overflow-y: auto;
                    bottom: 100%;
                    left: 0;
                }

                /* Ajustes para o botão de alternância do seletor de ícones */
                #iconSelectorToggle {
                    padding: 5px;
                    font-size: 12px;
                }

                /* Ajuste do preview do ícone selecionado */
                #iconPreview {
                    width: 30px;
                    height: 30px;
                }
            }








            .form-group {
                margin-bottom: 15px;
            }

            .form-group label {
                display: flex;
                align-items: center;
                font-weight: bold;
            }

            .form-group label i {
                margin-right: 8px;
            }

            /* Tamanho de fonte padrão para botões do Swal */
            .swal2-confirm, .swal2-cancel {
                font-size: 16px; /* Tamanho padrão para desktops e telas maiores */
                padding: 10px 20px; /* Padding padrão */
                flex: 1 1 auto; /* Flex-grow e flex-shrink para permitir ajuste */
                max-width: 200px; /* Largura máxima para evitar botões muito largos */
            }

            /* Estilos para o contêiner de ações do Swal */
            .swal2-actions {
                display: flex;
                flex-wrap: nowrap; /* Evita que os botões quebrem em múltiplas linhas */
                justify-content: center; /* Centraliza os botões */
                gap: 10px; /* Espaçamento entre os botões */
            }
            
            /* Estilos para o botão de "Desenho a mão livre" */
            .leaflet-control-freehand {
                background-color: white;
                width: 30px;
                height: 30px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Estilos para o ícone dentro do botão */
            .leaflet-control-freehand i {
                font-size: 29px;
                margin: 0;
            }









        </style>
        <title>PlanMilT </title>
    </head>
    <body>
        <div id="map">
        </div>
        <div id="elevation-profile-container" style="display: none; position: relative;">
            <button id="close-btn" style="position: absolute; top: 0; right: 0;">Fechar</button>
            <canvas id="elevation-profile-canvas" width="400" height="200"></canvas>
        </div>
        <button id="toggleControlsBtn" class="toggle-controls">Mostrar Controles</button>




        <!-- Adicionando FontAwesome para usar ícones -->
        <link href="css/all.min.css" rel="stylesheet">
        <script src="js/leaflet.js"></script>
        <script src="js/leaflet.rotatedMarker.js"></script>
        <script src="js/leaflet.pattern.js"></script>
        <script src="js/leaflet-hash.js"></script>
        <script src="js/Autolinker.min.js"></script>
        <script src="js/rbush.min.js"></script>
        <script src="js/labelgun.min.js"></script>
        <script src="js/labels.js"></script>
        <script src="js/leaflet-control-geocoder.Geocoder.js"></script>
        <script src="js/leaflet.draw.js"></script>
        <script src="js/leaflet.browser.print.min.js"></script>
        <script src="js/leaflet-measure.js"></script>

        <script src="js/jszip.min.js"></script>

        <!-- Proj4js -->
        <script src="js/proj4.js"></script>
        <script src="js/proj4leaflet.js"></script>

        <script src="js/Leaflet.MetricGrid.js"></script>

        <!-- SweetAlert2 JS -->
        <script src="js/sweetalert2@11.js"></script>

        <!-- Inclua o plugin Leaflet.VectorGrid Bundled -->
        <script src="js/Leaflet.VectorGrid.bundled.js"></script>

        <!-- Inclua o JS do Leaflet Control Geocoder -->
        <script src="js/Control.Geocoder.js"></script>

        <script src="js/clustering.js"></script>
        











        <script>



            var defaultColor = '#bada55'; // Cor padrão
            var map = L.map('map', {
                zoomControl: true,
                maxZoom: 28,
                minZoom: 1,
                tap: true, // Habilita eventos de toque em dispositivos móveis
                touchZoom: true, // Habilita o zoom por toque
                dragging: true // Garante que o arrasto do mapa esteja ativado
            }).fitBounds([[-21.666684470453795,-51.420400265474385],[-21.473097026357785,-51.07103186636465]]);
            // Definição do controle personalizado
            var MapToolbarControl = L.Control.extend({
                onAdd: function(map) {
                    // Cria um elemento div para a toolbar
                    var div = L.DomUtil.create('div', 'map-toolbar');

                    // Aqui você pode adicionar os botões e outros elementos HTML à sua toolbar
                    div.innerHTML = `
<div class="toolbar-item">
<div id="iconSelectorContainer">
<button id="iconSelectorToggle">Selecionar ícone</button>
<div id="iconSelectorContent" style="display: none;">
<!-- O conteúdo do seletor de ícones será inserido aqui -->
            </div>
            </div>
<img id="iconPreview" style="display:none;" />

<!-- Opções serão adicionadas dinamicamente pelo JavaScript -->
            </select>
<img id="iconPreview" src="" alt="Ícone selecionado" style="width: 30px; height: 30px; display: none;">
            </div>
<div class="toolbar-icons">
<i id="exportKMZ" class="fas fa-file-export toolbar-icon" title="Exportar para KMZ"></i>
<i id="importKMZ" class="fas fa-file-import toolbar-icon" title="Importar arquivo KMZ"></i>
<i id="locateMeButton" class="fas fa-map-marker-alt toolbar-icon" title="Mostrar/esconder minha localização"></i>
<i id="saveDrawings" class="fas fa-save toolbar-icon" title="Salvar desenhos"></i>
<i id="loadDrawings" class="fas fa-download toolbar-icon" title="Carregar desenhos"></i>
<i id="loadImages" class="fas fa-images toolbar-icon" title="Carregar imagens"></i>
<i id="shareLink" class="fas fa-share-alt toolbar-icon" title="Compartilhar link com camadas"></i>
<i id="startPlanning" class="fas fa-network-wired toolbar-icon" title="Planejamento Automático"></i>
<i id="helpButton" class="fas fa-question-circle toolbar-icon" title="Ajuda"></i>
<input type="file" id="fileInput" accept=".kmz" style="display: none;">
            </div>
<div class="toolbar-item color-picker-label">
<input type='text' id="colorPicker" class="color-picker"/>
            </div>
<div class="toolbar-item">
<select id="layerSelector">
<option value="">Selecione um camada para transparência</option>
            </select>
            </div>
<div class="toolbar-item">
<label for="transparencySlider">Transparência:</label>
<input type="range" id="transparencySlider" min="0" max="100" value="100">
            </div>
`;

                    // Impede que eventos do mapa ocorram quando interagindo com a toolbar
                    L.DomEvent.disableClickPropagation(div);

                    return div;
                }
            });

            // Adiciona o controle personalizado ao mapa
            var mapToolbar = new MapToolbarControl({position: 'bottomleft'});
            mapToolbar.addTo(map);



            // Inicializa o seletor de cores
            $('#colorPicker').spectrum({
                color: defaultColor,
                showPalette: true,
                palette: [
                    ['#000', '#444', '#666', '#999', '#ccc', '#eee', '#f3f3f3', '#fff'],
                    ['#f00', '#f90', '#ff0', '#0f0', '#0ff', '#00f', '#90f', '#f0f'],
                    ['#f4cccc', '#fce5cd', '#fff2cc', '#d9ead3', '#d0e0e3', '#cfe2f3', '#d9d2e9', '#ead1dc'],
                    ['#ea9999', '#f9cb9c', '#ffe599', '#b6d7a8', '#a2c4c9', '#9fc5e8', '#b4a7d6', '#d5a6bd'],
                    ['#e06666', '#f6b26b', '#ffd966', '#93c47d', '#76a5af', '#6fa8dc', '#8e7cc3', '#c27ba0'],
                    ['#c00', '#e69138', '#f1c232', '#6aa84f', '#45818e', '#3d85c6', '#674ea7', '#a64d79'],
                    ['#900', '#b45f06', '#bf9000', '#38761d', '#134f5c', '#0b5394', '#351c75', '#741b47'],
                    ['#600', '#783f04', '#7f6000', '#274e13', '#0c343d', '#073763', '#20124d', '#4c1130']
                ],
                change: function(color) {
                    defaultColor = color.toHexString();
                    updateDrawControl(); // Atualiza a cor padrão no controle de desenho
                }
            });



            


            // Variável global para armazenar o botão
            var freehandButton;

            // Botão personalizado para desenho à mão livre
            var FreehandControl = L.Control.extend({
                options: {
                    position: 'topleft' // Posição separada dos outros botões
                },
                onAdd: function(map) {
                    var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom leaflet-control-freehand');

                    // Use um ícone de lápis do FontAwesome
                    container.innerHTML = '<i class="fas fa-pencil-alt"></i>';

                    // Adicionar tooltip ao passar o mouse
                    container.title = 'Desenho à mão livre';

                    container.onclick = function() {
                        activateFreehandDrawing();
                        updateFreehandButtonAppearance();
                    };

                    freehandButton = container; // Armazena a referência ao botão

                    return container;
                }
            });

            // Adicionar o controle ao mapa
            var freehandControl = new FreehandControl();
            map.addControl(freehandControl);

            // Adicionar o controle do Google Translate ao mapa
            var TranslateControl = L.Control.extend({
                options: {
                    position: 'topright' // Posição do botão no mapa
                },
                onAdd: function (map) {
                    // Cria um contêiner para o Google Translate
                    var div = L.DomUtil.create('div', 'google-translate-control leaflet-bar');
                    div.id = 'google_translate_element'; // O id que o Google Translate precisa
                    div.style.backgroundColor = 'white'; // Fundo branco para se integrar ao estilo do Leaflet
                    div.style.padding = '5px';
                    div.style.borderRadius = '5px'; // Deixe arredondado para ficar bonito
                    div.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)'; // Sombra para destacar
                    return div;
                }
            });

            // Adicionar o controle ao mapa
            map.addControl(new TranslateControl());

            // Inicializar o Google Translate
            function googleTranslateElementInit() {
                new google.translate.TranslateElement({
                    pageLanguage: 'pt'
                }, 'google_translate_element');
            }



            // Variáveis globais
            var isDrawing = false;
            var freehandPolyline;
            var freehandDrawingEnabled = false;

            function updateFreehandButtonAppearance() {
                if (freehandDrawingEnabled) {
                    freehandButton.style.backgroundColor = '#bada55'; // Indica que o modo está ativo
                } else {
                    freehandButton.style.backgroundColor = 'white';
                }
            }

            function activateFreehandDrawing() {
                if (freehandDrawingEnabled) {
                    // Desativa o desenho à mão livre
                    freehandDrawingEnabled = false;
                    map.getContainer().style.cursor = '';
                    map.off('mousedown', onStartDrawing);
                    map.off('mouseup', onEndDrawing);
                    map.off('mousemove', onDrawing);
                    L.DomEvent.off(map.getContainer(), 'touchstart', onStartDrawing);
                    L.DomEvent.off(map.getContainer(), 'touchmove', onDrawing);
                    L.DomEvent.off(map.getContainer(), 'touchend', onEndDrawing);
                } else {
                    // Ativa o desenho à mão livre
                    freehandDrawingEnabled = true;
                    map.getContainer().style.cursor = 'crosshair';
                    map.on('mousedown', onStartDrawing);
                    map.on('mouseup', onEndDrawing);
                    map.on('mousemove', onDrawing);
                    L.DomEvent.on(map.getContainer(), 'touchstart', onStartDrawing, { passive: false });
                    L.DomEvent.on(map.getContainer(), 'touchmove', onDrawing, { passive: false });
                    L.DomEvent.on(map.getContainer(), 'touchend', onEndDrawing, { passive: false });
                }

                // Atualiza a aparência do botão
                updateFreehandButtonAppearance();
            }

            // Prevenir comportamento padrão em dispositivos touch
            map.getContainer().addEventListener('touchstart', function(e) {
                if (freehandDrawingEnabled) {
                    e.preventDefault();
                }
            }, { passive: false });

            function onStartDrawing(e) {
                if (!freehandDrawingEnabled) return;
                e.preventDefault(); // Impede o comportamento padrão
                isDrawing = true;
                freehandPolyline = L.polyline([], { color: defaultColor });
                var latlng = e.latlng;
                if (!latlng) {
                    var touch = e.touches[0];
                    latlng = map.mouseEventToLatLng(touch);
                }
                if (latlng) {
                    freehandPolyline.addLatLng(latlng);
                }
                map.addLayer(freehandPolyline);
                map.dragging.disable();
                map.doubleClickZoom.disable();
                if (e.type === 'mousedown') {
                    L.DomEvent.on(map.getContainer(), 'mouseleave', onEndDrawing);
                }
            }

            function onDrawing(e) {
                if (isDrawing) {
                    e.preventDefault(); // Impede o comportamento padrão
                    var latlng = e.latlng;
                    if (!latlng) {
                        var touch = e.touches[0];
                        latlng = map.mouseEventToLatLng(touch);
                    }
                    if (latlng) {
                        freehandPolyline.addLatLng(latlng);
                    }
                }
            }
function onEndDrawing(e) {
    if (isDrawing) {
        e.preventDefault(); // Impede o comportamento padrão
        isDrawing = false;
        map.dragging.enable();
        map.doubleClickZoom.enable();
        if (e.type === 'mouseup') {
            L.DomEvent.off(map.getContainer(), 'mouseleave', onEndDrawing);
        }

        // Desativa o desenho à mão livre após completar o desenho
        activateFreehandDrawing();

        // Obter os pontos da linha desenhada
        var latlngs = freehandPolyline.getLatLngs();

        // Verificar se o primeiro e o último pontos estão próximos (em pixels)
        if (latlngs.length > 2) { // Precisamos de pelo menos três pontos para formar um polígono
            var firstLatLng = latlngs[0];
            var lastLatLng = latlngs[latlngs.length - 1];

            // Converter LatLngs para pontos na camada (pixels)
            var firstPoint = map.latLngToLayerPoint(firstLatLng);
            var lastPoint = map.latLngToLayerPoint(lastLatLng);

            // Calcular a distância em pixels
            var pixelDistance = firstPoint.distanceTo(lastPoint);

            // Definir um limite de distância em pixels para considerar os pontos próximos
            var pixelThreshold = 15; // Você pode ajustar esse valor conforme necessário

            if (pixelDistance <= pixelThreshold) {
                // Fechar o polígono conectando o último ponto ao primeiro
                latlngs.push(firstLatLng);

                // Criar um polígono com os mesmos pontos
                var polygon = L.polygon(latlngs, { color: defaultColor });

                // Remover a linha desenhada do mapa
                map.removeLayer(freehandPolyline);

                // Disparar o evento 'draw:created' com o polígono
                setTimeout(function() {
                    map.fire(L.Draw.Event.CREATED, {
                        layerType: 'polygon',
                        layer: polygon
                    });
                }, 0);

                return; // Encerrar a função aqui para evitar processar como linha
            }
        }

        // Se não for um polígono, mantemos como linha
        // Disparar o evento 'draw:created' para reutilizar a lógica existente
        setTimeout(function() {
            map.fire(L.Draw.Event.CREATED, {
                layerType: 'polyline',
                layer: freehandPolyline
            });
        }, 0);
    }
}















            // Declaração das variáveis globais
            var icons = {}; // Objeto para armazenar os ícones Leaflet
            var iconPaths = {}; // Objeto para mapear nomes de ícones para caminhos de imagem
            var selectedIcon = "null"; // Variável para armazenar o ícone selecionado (chave)
            var selectedIconPath = null; // Variável para armazenar o caminho do ícone selecionado

            // Função para carregar e agrupar ícones por diretório
            function loadIcons() {
                fetch('symbols/icons.php')
                    .then(response => response.json())
                    .then(data => {
                    data.forEach(iconPath => {
                        var pathParts = iconPath.split('/');
                        var iconFileName = pathParts.pop(); // Ex: 'iconName.svg'
                        var iconName = iconFileName.replace('.svg', '');
                        var directoryName = pathParts.pop(); // Nome da pasta

                        var optionValue = directoryName + "/" + iconName;

                        // Cria o ícone Leaflet
                        icons[optionValue] = L.icon({
                            iconUrl: iconPath,
                            iconSize: [40, 40],
                            iconAnchor: [15, 15],
                            popupAnchor: [0, -15]
                        });

                        // Mapeia o nome do ícone para o caminho da imagem
                        iconPaths[optionValue] = iconPath;
                    });

                    // Constrói a interface do seletor de ícones
                    buildIconSelector();
                })
                    .catch(error => console.error('Erro ao carregar ícones:', error));
            }

            // Função para construir a interface de seleção de ícones
            function buildIconSelector() {
                var iconSelectorContainer = document.getElementById('iconSelectorContainer');

                // Limpa o conteúdo existente
                iconSelectorContainer.innerHTML = '';

                // Cria o botão "Selecionar ícone"
                var iconSelectorToggle = document.createElement('button');
                iconSelectorToggle.id = 'iconSelectorToggle';
                iconSelectorToggle.textContent = 'Selecionar ícone';
                iconSelectorContainer.appendChild(iconSelectorToggle);

                // Cria o conteúdo do seletor de ícones
                var iconSelectorContent = document.createElement('div');
                iconSelectorContent.id = 'iconSelectorContent';
                iconSelectorContent.style.display = 'none';
                iconSelectorContainer.appendChild(iconSelectorContent);

                // Agrupa os ícones por diretório
                var iconsByDirectory = {};

                for (var optionValue in iconPaths) {
                    var parts = optionValue.split('/');
                    var directoryName = parts[0];
                    var iconName = parts[1];

                    if (!iconsByDirectory[directoryName]) {
                        iconsByDirectory[directoryName] = [];
                    }

                    iconsByDirectory[directoryName].push({
                        iconName: iconName,
                        optionValue: optionValue,
                        iconPath: iconPaths[optionValue]
                    });
                }

                // Container para as pastas
                var folderList = document.createElement('div');
                folderList.className = 'folder-list';

                // Container para os ícones
                var iconList = document.createElement('div');
                iconList.className = 'icon-list';

                // Cria botões para cada pasta
                Object.keys(iconsByDirectory).forEach(directoryName => {
                    var folderButton = document.createElement('button');
                    folderButton.textContent = directoryName;
                    folderButton.dataset.directory = directoryName;
                    folderButton.className = 'folder-button';

                    folderButton.addEventListener('click', function() {
                        var selectedDirectory = this.dataset.directory;
                        // Limpa a lista de ícones
                        iconList.innerHTML = '';

                        // Exibe os ícones da pasta selecionada
                        iconsByDirectory[selectedDirectory].forEach(iconData => {
                            var iconItem = document.createElement('div');
                            iconItem.className = 'icon-item';

                            var img = document.createElement('img');
                            img.src = iconData.iconPath;
                            img.alt = iconData.iconName;
                            img.title = iconData.iconName;
                            img.dataset.optionValue = iconData.optionValue;
                            img.className = 'icon-image';

                            // Evento de clique para selecionar o ícone
                            img.addEventListener('click', function() {
                                var selectedOptionValue = this.dataset.optionValue;

                                // Atualiza a pré-visualização do ícone
                                var iconPreview = document.getElementById('iconPreview');
                                iconPreview.src = iconPaths[selectedOptionValue];
                                iconPreview.style.display = 'inline';
                                iconPreview.style.width = '40px';
                                iconPreview.style.height = '40px';

                                // Armazena o ícone selecionado
                                selectedIcon = selectedOptionValue;

                                // Armazena o caminho do ícone selecionado
                                selectedIconPath = iconPaths[selectedOptionValue];

                                // Oculta o seletor de ícones
                                iconSelectorContent.style.display = 'none';

                                // Atualiza o texto do botão para o nome do ícone selecionado (opcional)
                                iconSelectorToggle.textContent = 'Ícone selecionado: ';
                            });

                            iconItem.appendChild(img);
                            iconList.appendChild(iconItem);
                        });
                    });

                    folderList.appendChild(folderButton);
                });

                iconSelectorContent.appendChild(folderList);
                iconSelectorContent.appendChild(iconList);

                // Evento para mostrar/ocultar o seletor de ícones
                iconSelectorToggle.addEventListener('click', function() {
                    if (iconSelectorContent.style.display === 'none' || iconSelectorContent.style.display === '') {
                        iconSelectorContent.style.display = 'block';
                    } else {
                        iconSelectorContent.style.display = 'none';
                    }
                });
            }

            // Chamada inicial para carregar os ícones
            loadIcons();

            // Função para obter a chave do ícone selecionado (equivalente ao valor do seletor)
            function getSelectedIconKey() {
                return selectedIcon;
            }
            
            // Adicione o controle de busca ao mapa
            L.Control.geocoder({
                position: 'topright', // Posição do controle no mapa
                placeholder: 'Buscar cidade...', // Texto de placeholder
                errorMessage: 'Local não encontrado.',
                defaultMarkGeocode: false // Não adiciona um marcador no local encontrado
            })
                .on('markgeocode', function(e) {
                var latlng = e.geocode.center;
                var bbox = e.geocode.bbox;

                // Centraliza o mapa na localização encontrada
                map.fitBounds(bbox);

                // Opcional: Ajustar o nível de zoom diretamente
                // map.setView(latlng, 13); // Use um nível de zoom específico, se preferir
            })
                .addTo(map);









            var drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            // Função para atualizar o controle de desenho sem especificar um ícone por padrão
            function updateDrawControl() {
                if (map.drawControl) map.removeControl(map.drawControl);
                // Customização dos textos e tooltips
                L.drawLocal.draw.toolbar.buttons.polygon = 'Desenhar polígono';
                L.drawLocal.draw.toolbar.buttons.polyline = 'Desenhar linha';
                L.drawLocal.draw.toolbar.buttons.rectangle = 'Desenhar retângulo';
                L.drawLocal.draw.toolbar.buttons.circle = 'Desenhar círculo';
                L.drawLocal.draw.toolbar.buttons.marker = 'Adicionar ícone ou texto';
                L.drawLocal.draw.toolbar.buttons.circlemarker = 'Adicionar 2 pontos para linha de alturas';
                L.drawLocal.draw.toolbar.actions.title = 'Cancelar desenho';
                L.drawLocal.draw.toolbar.actions.text = 'Cancelar';
                L.drawLocal.draw.toolbar.undo.title = 'Deletar último ponto desenhado';
                L.drawLocal.draw.toolbar.undo.text = 'Deletar último ponto';
                L.drawLocal.edit.toolbar.actions.save.title = 'Salvar alterações';
                L.drawLocal.edit.toolbar.actions.save.text = 'Salvar';
                L.drawLocal.edit.toolbar.actions.cancel.title = 'Cancelar edição, descarta todas as alterações';
                L.drawLocal.edit.toolbar.actions.cancel.text = 'Cancelar';
                L.drawLocal.edit.toolbar.actions.clearAll.title = 'Limpar todos os desenhos';
                L.drawLocal.edit.toolbar.actions.clearAll.text = 'Limpar tudo';
                // Continuação da customização dos textos e tooltips
                L.drawLocal.draw.handlers.polygon.tooltip.start = 'Clique para começar a desenhar o polígono.';
                L.drawLocal.draw.handlers.polygon.tooltip.cont = 'Clique para continuar desenhando o polígono.';
                L.drawLocal.draw.handlers.polygon.tooltip.end = 'Clique no primeiro ponto para fechar este polígono.';
                L.drawLocal.draw.handlers.polyline.tooltip.start = 'Clique para começar a desenhar a linha.';
                L.drawLocal.draw.handlers.polyline.tooltip.cont = 'Clique para continuar desenhando a linha.';
                L.drawLocal.draw.handlers.polyline.tooltip.end = 'Clique no último ponto para terminar a linha.';
                L.drawLocal.draw.handlers.rectangle.tooltip.start = 'Clique e arraste para desenhar o retângulo.';
                L.drawLocal.draw.handlers.circle.tooltip.start = 'Clique e arraste para desenhar o círculo.';
                L.drawLocal.draw.handlers.circle.radius = 'Solte o mouse para terminar de desenhar o círculo.';
                L.drawLocal.draw.handlers.marker.tooltip.start = 'Clique no mapa para colocar o marcador.';
                L.drawLocal.draw.handlers.circlemarker.tooltip.start = 'Clique no mapa para colocar o ponto inicial ou final.';
                L.drawLocal.edit.handlers.edit.tooltip.text = 'Arraste os manipuladores ou marcadores para editar a forma.';
                L.drawLocal.edit.handlers.edit.tooltip.subtext = 'Clique em cancelar para desfazer as alterações.';
                L.drawLocal.edit.handlers.remove.tooltip.text = 'Clique em uma forma para removê-la.';


                map.drawControl = new L.Control.Draw({
                    edit: {
                        featureGroup: drawnItems,
                        remove: true
                    },
                    draw: {
                        marker: {
                        },
                        polygon: {
                            shapeOptions: {
                                color: defaultColor
                            }
                        },
                        polyline: {
                            shapeOptions: {
                                color: defaultColor
                            }
                        },
                        rectangle: {
                            shapeOptions: {
                                color: defaultColor
                            }
                        },
                        circle: {
                            shapeOptions: {
                                color: defaultColor
                            }
                        },
                        circlemarker: true,
                    }
                });
                map.addControl(map.drawControl);
            }

            // Certifique-se de chamar updateDrawControl sem passar um selectedIconKey
            updateDrawControl();

            // Chamada inicial para configurar o controle de desenho
            updateDrawControl('defaultIcon'); // Use 'defaultIcon' como valor inicial

            // Função para gerar as coordenadas de um polígono que aproxima um círculo
            function getCirclePolygon(center, radius, numPoints = 64) {
                let coords = [];
                const {lat, lng} = center; // Extrai latitude e longitude do centro
                const d2r = Math.PI / 180; // Conversão de graus para radianos
                const r2d = 180 / Math.PI; // Conversão de radianos para graus
                const earthRadius = 6378137; // Raio da Terra em metros

                // Raio em latitude/longitude
                const radiusLat = (radius / earthRadius) * r2d;
                const radiusLng = radiusLat / Math.cos(lat * d2r);

                for (let i = 0; i < numPoints; i++) {
                    const theta = Math.PI * (i / (numPoints / 2));
                    const ex = lng + (radiusLng * Math.cos(theta)); // Coordenada x
                    const ey = lat + (radiusLat * Math.sin(theta)); // Coordenada y
                    coords.push([ey, ex]);
                }

                return [coords]; // Polígonos no GeoJSON esperam um array de arrays
            }



            //var centralPoint = null; // Armazena o ponto central escolhido no mapa-

            map.on(L.Draw.Event.CREATED, async function(e) {
                var type = e.layerType;
                var layer = e.layer; // Define a cor padrão para todos os desenhos

                if (type === 'circlemarker') {
                    if (profileMarkers.length >= 2) {
                        Swal.fire("Já existem dois pontos no mapa. Remova-os antes de adicionar novos.");
                        return;
                    }
                    drawnItems.addLayer(layer);
                    profileMarkers.push(layer);
                    if (profileMarkers.length === 2) {
                        console.log("Chamando função getElevationProfile()");
                        getElevationProfile(profileMarkers[0], profileMarkers[1]);
                    }
                    return;
                }
                
                 if (type === 'polyline') {
        // Opções de estilo para linhas
        const { value: dashOption } = await Swal.fire({
            title: 'Selecione o estilo da linha',
            input: 'select',
            inputOptions: {
                solid: 'Sólida',
                dashed: 'Tracejada',
                dotted: 'Pontilhada'
            },
            inputPlaceholder: 'Selecione um estilo',
            showCancelButton: true
        });

        if (dashOption !== undefined) {
            let dashArrayValue;
            switch(dashOption) {
                case 'solid':
                    dashArrayValue = null;
                    break;
                case 'dashed':
                    dashArrayValue = '10, 10';
                    break;
                case 'dotted':
                    dashArrayValue = '2, 6';
                    break;
            }

            layer.setStyle({
                color: defaultColor,
                dashArray: dashArrayValue
            });

            // Garantir que layer.feature e layer.feature.properties existam
            layer.feature = layer.feature || { type: 'Feature', properties: {} };
            layer.feature.properties.color = defaultColor;
            if (dashArrayValue) {
                layer.feature.properties.dashArray = dashArrayValue;
            }
        }

        drawnItems.addLayer(layer);
    } 

               if (type === 'polygon') {
        // Apresentar opções de preenchimento para o usuário
        const { value: fillOption } = await Swal.fire({
            title: 'Selecione o tipo de preenchimento',
            input: 'select',
            inputOptions: {
                solid: 'Cor Sólida',
                patternX: 'Padrão "X"',
                patternSlash: 'Padrão "\\"'
            },
            inputPlaceholder: 'Selecione um preenchimento',
            showCancelButton: true
        });

        if (fillOption !== undefined) {
            if (fillOption === 'solid') {
                layer.setStyle({
                    fillColor: defaultColor,
                    fillOpacity: 0.5
                });

                // Adicionar informações de estilo às propriedades da feature
                layer.feature = {
                    type: 'Feature',
                    properties: {
                        fillColor: defaultColor,
                        fillOpacity: 0.5
                    },
                    geometry: layer.toGeoJSON().geometry
                };
            } else {
                // Aplicar padrões de preenchimento
                let pattern;
                if (fillOption === 'patternX') {
                    pattern = new L.Pattern({
                        width: 8,
                        height: 8,
                        patternUnits: 'userSpaceOnUse'
                    });
                    var shape = new L.PatternPath({
                        d: 'M0,0 L8,8 M8,0 L0,8',
                        stroke: true,
                        weight: 1,
                        color: defaultColor
                    });
                    pattern.addShape(shape);
                    pattern.addTo(map);
                } else if (fillOption === 'patternSlash') {
                    pattern = new L.Pattern({
                        width: 8,
                        height: 8,
                        patternUnits: 'userSpaceOnUse'
                    });
                    var shape = new L.PatternPath({
                        d: 'M0,0 L8,8',
                        stroke: true,
                        weight: 1,
                        color: defaultColor
                    });
                    pattern.addShape(shape);
                    pattern.addTo(map);
                }

                layer.setStyle({
                    fillPattern: pattern
                });

                // Adicionar informações de estilo às propriedades da feature
                layer.feature = {
                    type: 'Feature',
                    properties: {
                        fillPattern: fillOption,
                        color: defaultColor
                    },
                    geometry: layer.toGeoJSON().geometry
                };
            }
        }

                   drawnItems.addLayer(layer);
               }

                if (type === 'circle') {
                    var center = layer.getLatLng();
                    var radius = layer.getRadius();

                    var polygonCoordinates = getCirclePolygon(center, radius);

                    var polygonLayer = L.polygon(polygonCoordinates, {
                        color: defaultColor,
                        fillColor: defaultColor,
                        fillOpacity: 0.5,
                    }).addTo(drawnItems);

                    polygonLayer.feature = {
                        type: 'Feature',
                        properties: {
                            shape: 'circle',
                            center: [center.lat, center.lng],
                            radius: radius,
                            color: defaultColor
                        },
                        geometry: {
                            type: "Polygon",
                            coordinates: [polygonCoordinates]
                        }
                    };
                } else if (type === 'marker') {
                    // Substituindo o confirm() por SweetAlert2
                    const result = await Swal.fire({
                        title: 'Adicionar Ícone ou Texto?',
                        text: "Clique em 'Ícone' para adicionar ícone ou 'Texto' para adicionar um texto.",
                        icon: 'question',
                        showCancelButton: true,
                        confirmButtonText: 'Ícone',
                        cancelButtonText: 'Texto'
                    });

                    var addText = !result.isConfirmed;

                    if (addText) {
                        openTextEditor(layer.getLatLng(), function(content) {
                            var customIcon = L.divIcon({
                                className: 'custom-text-label',
                                html: content,
                                iconSize: [200,50],
                                iconAnchor: [0, 0]
                            });
                            layer.setIcon(customIcon);
                            layer.feature = {
                                type: 'Feature',
                                properties: {
                                    text: content,
                                    color: defaultColor
                                },
                                geometry: layer.toGeoJSON().geometry
                            };
                            drawnItems.addLayer(layer);
                        });
                    } else {
                        var selectedIconKey = getSelectedIconKey();
                        var iconUrl = icons[selectedIconKey] ? icons[selectedIconKey].options.iconUrl : '';

                        if (iconUrl) {
                            // Define o ícone para a camada
                            layer.setIcon(icons[selectedIconKey]);

                            // Adiciona propriedades personalizadas à camada
                            layer.feature = {
                                type: 'Feature',
                                properties: {
                                    iconUrl: iconUrl,
                                    color: defaultColor
                                },
                                geometry: layer.toGeoJSON().geometry
                            };
                        } else {
                            // Exibe um alerta ao usuário informando que nenhum ícone foi selecionado
                            Swal.fire({
                                title: 'Ícone Não Selecionado',
                                text: 'Por favor, selecione um ícone antes de adicionar ao mapa.',
                                icon: 'warning',
                                confirmButtonText: 'OK'
                            });

                            // Opcional: Retorna ou encerra a execução para evitar ações adicionais
                            return;
                        }
                    }


                    // Adiciona explicitamente o marcador ao drawnItems
                    drawnItems.addLayer(layer);
                } else {
        // Outros tipos de camadas
        layer.feature = layer.feature || { type: 'Feature', properties: {} };
        layer.feature.properties.color = defaultColor;
        drawnItems.addLayer(layer);
    }

    // Exibir o GeoJSON gerado
    console.log('GeoJSON com propriedades de estilo:', JSON.stringify(drawnItems.toGeoJSON()));
});




            document.getElementById('importKMZ').addEventListener('click', function() {
                document.getElementById('fileInput').click(); // Deve acionar o clique no input de arquivo
            });


            function editText(layer, latlng) {
                openTextEditor(latlng, function(content) {
                    layer.feature.properties.text = content;
                    layer.setIcon(L.divIcon({
                        className: 'custom-text-label',
                        html: content,
                        iconSize: null,
                        iconAnchor: [0, 0]
                    }));
                }, layer.feature.properties.text);
            }


            drawnItems.on('click', function(e) {
                var layer = e.layer;
                var latlng = e.latlng; // Certifique-se de obter as coordenadas do clique
                if (layer.feature && layer.feature.properties && layer.feature.properties.text) {
                    editText(layer, latlng);
                }
                else {
                    try {
                        var latlng = layer.getLatLng();
                        var utm = latLngToUtm(latlng.lat, latlng.lng);

                        // Exibe um popup com as coordenadas UTM
                        L.popup()
                            .setLatLng(latlng)
                            .setContent(`Coordenadas Métricas (UTM): (${utm.easting}, ${utm.northing})`)
                            .openOn(map);
                    }
                    catch (e){

                    }
                }
            });
            function getUtmZone(lng) {
                return Math.floor((lng + 180) / 6) + 1;
            }

            function getHemisphere(lat) {
                return lat >= 0 ? 'north' : 'south';
            }

            function latLngToUtm(lat, lng) {
                var utmZone = getUtmZone(lng);
                var hemisphere = getHemisphere(lat);
                var proj4Str = `+proj=utm +zone=${utmZone} +${hemisphere} +datum=WGS84 +units=m +no_defs`;

                // Converte para coordenadas UTM usando proj4js
                var utmCoordinates = proj4('EPSG:4326', proj4Str, [lng, lat]);

                return {
                    zone: utmZone,
                    easting: Math.round(utmCoordinates[0]),
                    northing: Math.round(utmCoordinates[1]),
                    hemisphere: hemisphere
                };
            }



            function openTextEditor(latlng, callback, initialContent = '') {
                var popupContent = `
<div id="text-editor-popup" style="width: 400px;">
<textarea id="tiny-editor" style="width: 400px; height: 200px;">${initialContent}</textarea>
<button id="save-text" style="margin-top: 10px;">Salvar</button>
<button id="cancel-text" style="margin-top: 10px;">Cancelar</button>
            </div>
`;

                var popup = L.popup({ maxWidth: 400 })
                .setLatLng(latlng) // Usa as coordenadas do clique para definir a localização do popup
                .setContent(popupContent)
                .openOn(map);

                tinymce.init({
                    selector: '#tiny-editor',
                    plugins: 'textcolor', // Não é necessário carregar o plugin de fontsize
                    toolbar: 'bold italic underline | fontsizeselect | forecolor backcolor', // Use 'fontsizeselect' para selecionar o tamanho da fonte
                    menubar: false,
                    fontsize_formats: '8pt 10pt 12pt 14pt 18pt 24pt 36pt', // Opções predefinidas de tamanho de fonte
                    setup: function (editor) {
                        editor.on('init', function () {
                            editor.setContent(initialContent);
                        });
                    }
                });



                document.getElementById('save-text').addEventListener('click', function () {
                    var content = tinymce.get('tiny-editor').getContent();
                    tinymce.remove('#tiny-editor');
                    map.closePopup(popup);
                    callback(content);
                });

                document.getElementById('cancel-text').addEventListener('click', function () {
                    tinymce.remove('#tiny-editor');
                    map.closePopup(popup);
                });
            }





            document.getElementById('fileInput').addEventListener('change', function(e) {
                var file = e.target.files[0];
                if (file) {
                    var reader = new FileReader();
                    reader.onload = function(event) {
                        JSZip.loadAsync(event.target.result).then(function(zip) {
                            var kmlFile = zip.file("doc.kml");

                            if (!kmlFile) {
                                // Procurar qualquer arquivo .kml caso doc.kml não seja encontrado
                                var kmlFiles = zip.file(/\.kml$/);
                                if (kmlFiles.length > 0) {
                                    kmlFile = kmlFiles[0];
                                }
                            }

                            if (kmlFile) {
                                kmlFile.async("string").then(function(kmlContent) {
                                    // Criar a camada de importação
                                    var importLayer = L.layerGroup().addTo(map);

                                    // Processar imagens e adicioná-las à camada de importação
                                    processImagesFromKML(kmlContent, zip, importLayer);
                                    // Processar estilos, linhas e overlays e adicioná-las à camada de importação
                                    processStylesAndLinesFromKML(kmlContent, importLayer);
                                    processGroundOverlaysFromKML(kmlContent, zip, importLayer);

                                    // Obter o nome do arquivo KMZ sem a extensão
                                    var fileName = file.name.replace(/\.kmz$/i, '');

                                    // Adicionar a camada de importação ao controle de camadas com o nome do arquivo KMZ
                                    layerControl.addOverlay(importLayer, fileName);
                                });
                            } else {
                                console.error("Nenhum arquivo KML encontrado no ZIP.");
                            }
                        });
                    };
                    reader.readAsArrayBuffer(file);
                }
            });

            function processImagesFromKML(kmlContent, zip, importLayer) {
                var parser = new DOMParser();
                var kmlDoc = parser.parseFromString(kmlContent, 'application/xml');

                var iconNodes = kmlDoc.querySelectorAll('IconStyle > Icon > href');
                var placemarks = kmlDoc.querySelectorAll('Placemark');

                var iconCache = {};

                iconNodes.forEach(function(iconNode) {
                    var iconPath = iconNode.textContent.trim();
                    console.log("Processing icon:", iconPath);

                    if (!iconCache[iconPath] && zip.file(iconPath)) {
                        zip.file(iconPath).async("base64").then(function(imageData) {
                            var imgSrc = "data:image/png;base64," + imageData;
                            iconCache[iconPath] = imgSrc;

                            placemarks.forEach(function(placemark) {
                                var styleUrl = placemark.querySelector('styleUrl');
                                if (styleUrl && styleUrl.textContent.includes(iconPath)) {
                                    var coordinates = placemark.querySelector('coordinates').textContent.trim().split(',');
                                    var latLng = L.latLng(parseFloat(coordinates[1]), parseFloat(coordinates[0]));

                                    var customIcon = L.icon({
                                        iconUrl: imgSrc,
                                        iconSize: [40, 40],
                                        iconAnchor: [20, 20],
                                        popupAnchor: [0, -20]
                                    });

                                    var marker = L.marker(latLng, { icon: customIcon });
                                    marker.addTo(importLayer);
                                }
                            });
                        }).catch(function(error) {
                            console.error("Error reading image file:", error);
                        });
                    }
                });

                placemarks.forEach(function(placemark) {
                    var geometryType = placemark.querySelector('Point, LineString, Polygon');
                    if (geometryType) {
                        var coordinates = placemark.querySelector('coordinates').textContent.trim().split(' ');
                        var latLngs = coordinates.map(function(coord) {
                            var [lng, lat] = coord.split(',').map(parseFloat);
                            return [lat, lng];
                        });

                        if (geometryType.nodeName === 'LineString') {
                            var lineStyle = placemark.querySelector('LineStyle');
                            var color = lineStyle ? lineStyle.querySelector('color').textContent : '#3388ff';
                            var width = lineStyle ? parseFloat(lineStyle.querySelector('width').textContent) : 2;

                            L.polyline(latLngs, { color: color, weight: width }).addTo(importLayer);
                        }
                    }
                });

                console.log("Import completed. Added layers:", importLayer.getLayers());
            }

            function processStylesAndLinesFromKML(kmlContent, importLayer) {
                var parser = new DOMParser();
                var kmlDoc = parser.parseFromString(kmlContent, 'application/xml');

                var linePlacemarks = kmlDoc.querySelectorAll('Placemark LineString');
                linePlacemarks.forEach(function(linePlacemark) {
                    var styleNode = linePlacemark.parentNode.querySelector('Style LineStyle color');
                    var color = styleNode ? kmlColorToHex(styleNode.textContent.trim()) : '#0000ff';

                    var coordinates = linePlacemark.querySelector('coordinates').textContent.trim().split(' ');
                    var latLngs = coordinates.map(function(coord) {
                        var parts = coord.split(',');
                        return [parseFloat(parts[1]), parseFloat(parts[0])];
                    });
                    L.polyline(latLngs, { color: color }).addTo(importLayer);
                });
            }

            function processGroundOverlaysFromKML(kmlContent, zip, importLayer) {
                var parser = new DOMParser();
                var kmlDoc = parser.parseFromString(kmlContent, 'application/xml');

                var overlayNodes = kmlDoc.querySelectorAll('GroundOverlay');

                overlayNodes.forEach(function(overlayNode) {
                    var iconPath = overlayNode.querySelector('Icon > href').textContent.trim();
                    console.log("Processing overlay icon:", iconPath);

                    if (zip.file(iconPath)) {
                        zip.file(iconPath).async("base64").then(function(imageData) {
                            var imgSrc = "data:image/png;base64," + imageData;

                            var latLonBox = overlayNode.querySelector('LatLonBox');
                            var bounds = [
                                [parseFloat(latLonBox.querySelector('south').textContent), parseFloat(latLonBox.querySelector('west').textContent)],
                                [parseFloat(latLonBox.querySelector('north').textContent), parseFloat(latLonBox.querySelector('east').textContent)]
                            ];

                            var overlay = L.imageOverlay(imgSrc, bounds);
                            overlay.addTo(importLayer);
                        }).catch(function(error) {
                            console.error("Error reading overlay image file:", error);
                        });
                    }
                });
            }

            function kmlColorToHex(kmlColor) {
                if (kmlColor.length === 8) {
                    var alpha = kmlColor.substr(0, 2);
                    var blue = kmlColor.substr(2, 2);
                    var green = kmlColor.substr(4, 2);
                    var red = kmlColor.substr(6, 2);
                    return '#' + red + green + blue;
                }
                return kmlColor;
            }











            var hash = new L.Hash(map);
            map.attributionControl.setPrefix('<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>');
            var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});
            function removeEmptyRowsFromPopupContent(content, feature) {
                var tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                var rows = tempDiv.querySelectorAll('tr');
                for (var i = 0; i < rows.length; i++) {
                    var td = rows[i].querySelector('td.visible-with-data');
                    var key = td ? td.id : '';
                    if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                        rows[i].parentNode.removeChild(rows[i]);
                    }
                }
                return tempDiv.innerHTML;
            }




            document.querySelector(".leaflet-popup-pane").addEventListener("load", function(event) {
                var tagName = event.target.tagName,
                    popup = map._popup;
                // Also check if flag is already set.
                if (tagName === "IMG" && popup && !popup._updated) {
                    popup._updated = true; // Set flag to prevent looping.
                    popup.update();
                }
            }, true);
            
            
            var measureControl = new L.Control.Measure({
                position: 'topright',
                primaryLengthUnit: 'meters',
                secondaryLengthUnit: 'kilometers',
                primaryAreaUnit: 'sqmeters',
                secondaryAreaUnit: 'hectares',
                activeColor: '#db4a29', // Cor das linhas ativas
                completedColor: '#9b2d14'
            });
            measureControl.addTo(map);

            // Personalizar o botão de alternância
            var measureToggleButton = document.getElementsByClassName('leaflet-control-measure-toggle')[0];
            measureToggleButton.innerHTML = '';
            measureToggleButton.className += ' fas fa-ruler';
            measureToggleButton.title = 'Medição'; // Adiciona um título em português



            var bounds_group = new L.featureGroup([]);
            function setBounds() {
            }



            // Adiciona o botão de exportação
            L.control.browserPrint({
                position: 'topright',
                title: 'Print ...',
            }).addTo(map);

            // Adiciona o controle de escala ao mapa
            L.control.scale({maxWidth: 100, metric: true, imperial: false, position: 'bottomleft'}).addTo(map);

            // Adiciona um evento de clique ao botão de impressão
            document.querySelector('.leaflet-control-browser-print a').addEventListener('click', function() {
                var originalZoom = map.getZoom();
                var targetZoom = 13; // Defina o nível de zoom desejado para a escala 1:50000

                // Ajusta o zoom do mapa para a escala desejada
                map.setZoom(targetZoom);

                // Garante que o controle de escala seja atualizado
                map.on('zoomend', function() {
                    setTimeout(function() {
                        // Chama a função de impressão padrão do navegador
                        window.print();

                        // Restaura o zoom original após a impressão
                        map.setZoom(originalZoom);
                    }, 1000); // Aguarda 1 segundo antes de imprimir para garantir que o mapa e a escala sejam atualizados
                });
            });







            // Função para salvar os desenhos via AJAX
            function salvarDesenhos(usuario, senha, drawnData, diretorio) {
                console.log('--- Iniciando salvarDesenhos ---');
                console.log('Usuário:', usuario);
                console.log('Diretório:', diretorio);
                console.log('Dados dos desenhos antes de personalizar:', drawnData);

                // Itera por cada feature para incluir propriedades personalizadas
                drawnData.features.forEach(function(feature) {
                    var layer = drawnItems.getLayer(feature.properties._leaflet_id);
                    if (layer && layer.options) {
                        if (layer.options.icon) {
                            feature.properties.iconUrl = layer.options.icon.options.iconUrl;
                            console.log('iconUrl adicionado:', feature.properties.iconUrl);
                        }
                        // Para formas que não são marcadores, salvar a cor
                        if (layer.options.color) {
                            feature.properties.color = layer.options.color;
                            console.log('Cor adicionada:', feature.properties.color);
                        }
                    }
                });

                console.log('Dados dos desenhos após personalização:', drawnData);

                var data = {
                    usuario: usuario,
                    senha: senha,
                    link: diretorio, // Diretório a ser usado na requisição
                    leaflet: JSON.stringify(drawnData) // Converte os dados desenhados para uma string JSON
                };

                console.log('Dados a serem enviados via AJAX:', data);

                // Envio dos dados via AJAX
                $.ajax({
                    type: "POST",
                    url: "/salvar.php", // Substitua pelo caminho correto para sua página PHP
                    data: data,
                    success: function(response) {
                        console.log('Resposta recebida do servidor:', response);

                        // Verifica se a resposta contém a frase "Desenho atualizado com sucesso!"
                        if (response.includes("Desenho atualizado com sucesso!") || response.includes("Desenho salvo com sucesso!")) {
                            Swal.fire('Sucesso!', 'Desenhos salvos com sucesso!', 'success');
                            console.log('Desenhos salvos com sucesso!');
                        } else {
                            // Se a resposta não contém a frase esperada, trata como erro
                            Swal.fire('Erro!', response, 'error');
                            console.error('Erro ao salvar desenhos:', response);
                        }
                    },
                    error: function(xhr, status, error) {
                        console.error("Erro ao salvar desenhos via AJAX:", error);
                        Swal.fire('Erro!', 'Não foi possível salvar os desenhos.', 'error');
                    }
                });
            }


            // Recupera usuário e senha salvos, ou define como string vazia se não existir
            const savedUsuario = '';
            const savedSenha = '';

            document.getElementById('saveDrawings').addEventListener('click', function() {
                // Recupera usuário e senha salvos, ou define como string vazia se não existir
                const savedUsuario = sessionStorage.getItem('usuario') || '';
                const savedSenha = sessionStorage.getItem('senha') || '';

                // Utiliza o SweetAlert2 para solicitar o usuário e senha
                Swal.fire({
                    title: 'Insira suas credenciais',
                    html: `
<input type="text" id="swal-input-usuario" class="swal2-input" placeholder="Usuário" value="${savedUsuario}">
<input type="password" id="swal-input-senha" class="swal2-input" placeholder="Senha" value="${savedSenha}">
`,
                    focusConfirm: false,
                    preConfirm: () => {
                        const usuario = document.getElementById('swal-input-usuario').value;
                        const senha = document.getElementById('swal-input-senha').value;
                        if (!usuario || !senha) {
                            Swal.showValidationMessage('Usuário e senha são necessários!');
                            return false;
                        }
                        return { usuario: usuario, senha: senha };
                    }
                }).then((result) => {
                    if (result.isConfirmed) {
                        var { usuario, senha } = result.value;

                        // Salva usuário e senha no sessionStorage
                        sessionStorage.setItem('usuario', usuario);
                        sessionStorage.setItem('senha', senha);

                        // Gera o GeoJSON dos desenhos
                        var drawnData = drawnItems.toGeoJSON();

                        // Verifica se não há desenhos para salvar
                        if (drawnData.features.length === 0) {
                            // Informa o usuário e pergunta se deseja continuar
                            Swal.fire({
                                title: 'Nenhum desenho encontrado',
                                text: 'Não há desenhos para salvar. Deseja continuar salvando mesmo assim?',
                                icon: 'warning',
                                showCancelButton: true,
                                confirmButtonText: 'Sim, salvar mesmo assim',
                                cancelButtonText: 'Cancelar'
                            }).then((confirmResult) => {
                                if (confirmResult.isConfirmed) {
                                    // Obtém a URL completa da janela atual
                                    const urlCompleta = window.location.href;

                                    // Extrai o diretório a partir da URL completa
                                    const padraoDiretorio = /https:\/\/methodux\.online\/(.*?)\//;
                                    const resultado = padraoDiretorio.exec(urlCompleta);

                                    // A variável 'diretorio' conterá o diretório atual, ou uma string vazia se não encontrado
                                    const diretorio = resultado ? resultado[1] : '';

                                    // Prossegue com o salvamento mesmo sem desenhos
                                    salvarDesenhos(usuario, senha, drawnData, diretorio);
                                } else {
                                    // Se o usuário cancelar, aborta o salvamento
                                    Swal.fire('Salvamento cancelado', 'Nenhum desenho foi salvo.', 'info');
                                }
                            });
                            // Retorna para evitar que o código continue imediatamente
                            return;
                        }

                        // Obtém a URL completa da janela atual
                        const urlCompleta = window.location.href;

                        // Extrai o diretório a partir da URL completa
                        const padraoDiretorio = /https:\/\/methodux\.online\/(.*?)\//;
                        const resultado = padraoDiretorio.exec(urlCompleta);

                        // A variável 'diretorio' conterá o diretório atual, ou uma string vazia se não encontrado
                        const diretorio = resultado ? resultado[1] : '';

                        // Prossegue com o salvamento normalmente
                        salvarDesenhos(usuario, senha, drawnData, diretorio);
                    }
                });
            });







            // Função para verificar se o objeto é do tipo GeoJSON
            function isValidGeoJson(geoJsonObject) {
                return geoJsonObject && typeof geoJsonObject === 'object' && 
                    (geoJsonObject.type === 'Feature' || geoJsonObject.type === 'FeatureCollection') &&
                    (geoJsonObject.type === 'FeatureCollection' ? geoJsonObject.features && Array.isArray(geoJsonObject.features) : true);
            }







            // Carrega novas camadas se existir o parâmetro GET com múltiplas camadas separadas por vírgulas
            document.addEventListener('DOMContentLoaded', async function() {
                // Cria um objeto URL com a URL atual
                const url = new URL(window.location.href);

                // Utiliza o URLSearchParams para analisar a string de consulta
                const params = new URLSearchParams(url.search);

                // Verifica se a variável 'camada' está presente na URL e obtém o valor como uma string
                const camadasParam = params.get('camada');
                const urlCompleta = window.location.href;

                const calco = params.get('calco');
                if (calco) {
                    loadImageFromId(calco);
                }

                var toolbar = document.querySelector('.map-toolbar');
                var drawToolbar = document.querySelectorAll('.leaflet-draw-toolbar');
                var printButton = document.querySelector('.leaflet-control-browser-print');



                // Extrai o diretório a partir da URL completa
                const padraoDiretorio = /https:\/\/methodux\.online\/(.*?)\//;
                const resultado = padraoDiretorio.exec(urlCompleta);
                const diretorio = resultado ? resultado[1] : '';

                // Separa as camadas se existirem múltiplas, separadas por vírgulas
                const camadas = camadasParam ? camadasParam.split(',') : [];

                try {
                    for (const camada of camadas) {
                        const response = await fetch("/carregar.php", { // Ajuste para o caminho correto do seu script PHP
                            method: "POST",
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: `usuario=${encodeURIComponent(camada)}&link=${encodeURIComponent(diretorio)}`
                        });

                        if (!response.ok) {
                            throw new Error(`Erro HTTP: ${response.status}`);
                        }

                        const geoJsonData = await response.json();

                        // Verifica se os dados obtidos são do tipo GeoJSON válido
                        if (!isValidGeoJson(geoJsonData)) {
                            console.log(`A camada solicitada ${camada} não é um GeoJSON válido ou não existe.`);
                            return; // Sai da função se não for um GeoJSON válido
                        }

                        console.log("Geojson carregado para a camada", camada, ":", geoJsonData);

                        // Define um nome único para a nova camada de desenhos
                        var newLayerName = camada;

                        // Prepara uma nova camada GeoJSON para adicionar ao mapa
                        var newLayer = L.geoJson(null).addTo(map);

                        // Processa e adiciona os dados GeoJSON à nova camada
                        L.geoJson(geoJsonData, {
                            onEachFeature: function(feature, layer) {
                                if (feature.geometry.type === 'Point' && Object.keys(feature.properties).length === 0) {
                                    console.log("Ponto vazio encontrado:", feature);
                                    // Configura um ícone transparente e sem tamanho para o layer
                                    var emptyIcon = L.divIcon({
                                        html: '', // Sem conteúdo HTML
                                        className: 'empty-icon', // Classe personalizada que pode ser usada para torná-lo invisível através de CSS, se necessário
                                        iconSize: [0, 0] // Tamanho do ícone definido como zero
                                    });
                                    layer.setIcon(emptyIcon); // Aplica o ícone vazio ao marcador
                                    newLayer.addLayer(layer);
                                }
                                else if (feature.geometry.type === 'Point' && feature.properties.shape === 'circle') {
                                    // Cria e adiciona o círculo diretamente ao drawnItems
                                    var newCircle = L.circle([feature.properties.center[0], feature.properties.center[1]], {
                                        color: feature.properties.color,
                                        fillColor: feature.properties.color,
                                        fillOpacity: 0.5,
                                        radius: feature.properties.radius
                                    });
                                    newLayer.addLayer(newCircle);
                                }
                                // Trata pontos com propriedade text, garantindo que não são círculos
                                else if (feature.properties.text && feature.geometry.type === 'Point' && !feature.properties.iconUrl) {
                                    var customIcon = L.divIcon({
                                        className: 'custom-text-label',
                                        html: feature.properties.text,
                                        iconSize: [100, 30],
                                        iconAnchor: [15, 15]
                                    });
                                    // Configura o ícone personalizado no marcador existente
                                    layer.setIcon(customIcon);
                                    newLayer.addLayer(layer);
                                }
                                // Trata ícones personalizados para pontos, garantindo que não são círculos
                                else if (feature.geometry.type === 'Point' && feature.properties.iconUrl && feature.properties.shape !== 'circle') {
                                    var customIcon = L.icon({
                                        iconUrl: feature.properties.iconUrl,
                                        iconSize: [40, 40],
                                        iconAnchor: [15, 15]
                                    });
                                    layer.setIcon(customIcon);
                                    newLayer.addLayer(layer);
                                }
                                // Aplica estilo para outros tipos de geometria
                                else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'Polygon'){
                                    layer.setStyle({color: feature.properties.color});
                                    newLayer.addLayer(layer);
                                }
                            }
                        });

                        // Adiciona 'newLayer' ao controle do mapa, assumindo que 'addNewOverlayLayer' está definido corretamente
                        addNewOverlayLayer(newLayerName, newLayer);
                    }
                } catch (error) {
                    console.error("Falha ao carregar desenhos:", error);
                }
            });








            document.getElementById('shareLink').addEventListener('click', async function () {
                const { value: formValues } = await Swal.fire({
                    title: 'Compartilhar Camadas Ativas',
                    html:
                    `<label for="userInput">Insira os nomes dos usuários:</label>
<input id="userInput" class="swal2-input" placeholder="Nome de usuário" type="text">
<div id="userList" style="margin-top: 10px;"></div>
<label for="imageSelect">Selecione as imagens:</label>
<select id="imageSelect" class="swal2-input" multiple style="width: 100%; height: 150px;" size="6"></select>
<button type="button" id="addUserBtn" class="swal2-confirm swal2-styled">Adicionar Usuário</button>`,
                    focusConfirm: false,
                    showCancelButton: true,
                    confirmButtonText: 'Gerar Link',
                    didOpen: () => {
                        // Função para adicionar usuários ao pressionar "Enter"
                        const userInput = document.getElementById('userInput');
                        userInput.addEventListener('keydown', (event) => {
                            if (event.key === 'Enter' && userInput.value.trim() !== '') {
                                addUserToList(userInput.value);
                                userInput.value = ''; // Limpa o campo de entrada
                            }
                        });

                        // Função para adicionar usuários ao clicar no botão "Adicionar Usuário"
                        document.getElementById('addUserBtn').addEventListener('click', () => {
                            if (userInput.value.trim() !== '') {
                                addUserToList(userInput.value);
                                userInput.value = ''; // Limpa o campo de entrada
                            }
                        });

                        // Carrega as imagens ao abrir o modal
                        loadImages();
                    },
                    preConfirm: () => {
                        const users = Array.from(document.querySelectorAll('#userList .user')).map(el => el.textContent.trim());
                        const images = Array.from(document.querySelectorAll('#imageSelect option:checked')).map(el => el.value);
                        if (!users.length) {
                            Swal.showValidationMessage('Você deve inserir pelo menos um nome de usuário!');
                            return false;
                        }
                        return { users, images };
                    }
                });

                if (formValues) {
                    const { users, images } = formValues;

                    // Função para obter o valor de um parâmetro da URL
                    function getParameterByName(name, url = window.location.href) {
                        name = name.replace(/[\[\]]/g, "\\$&");
                        let regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                            results = regex.exec(url);
                        if (!results) return null;
                        if (!results[2]) return '';
                        return decodeURIComponent(results[2].replace(/\+/g, " "));
                    }

                    const calcoValue = images.join(','); // IDs das imagens
                    const camadasParam = encodeURIComponent(users.join(',')); // Usuários separados por vírgula

                    // Função para obter o fragmento da URL (parte que começa com #)
                    const urlFragment = window.location.hash || '';

                    // Construir a URL no formato desejado com o fragmento no final
                    const novaURL = `https://aescoladatatica.fun/?calco=${calcoValue}&camada=${camadasParam}${urlFragment}`;


                    // Exibe o link gerado
                    Swal.fire({
                        title: 'Link Gerado',
                        html: `<p>Copie o link para compartilhar suas camadas e imagens ativas:</p>
<input type="text" id="link-gerado" class="swal2-input" value="${novaURL}" readonly>`,
                        confirmButtonText: 'Copiar Link',
                        showCancelButton: true,
                        cancelButtonText: 'Fechar',
                        preConfirm: () => {
                            const input = document.getElementById('link-gerado');
                            input.select();
                            document.execCommand('copy');
                            return 'Link copiado para a área de transferência!';
                        }
                    }).then((copyResult) => {
                        if (copyResult.isConfirmed) {
                            Swal.fire('Sucesso!', 'O link foi copiado para a área de transferência.', 'success');
                        }
                    });
                }

                // Função para adicionar um usuário à lista
                function addUserToList(userName) {
                    const userList = document.getElementById('userList');
                    const userDiv = document.createElement('div');
                    userDiv.className = 'user';
                    userDiv.textContent = userName;
                    userList.appendChild(userDiv);
                }

                // Função para carregar imagens do servidor
                async function loadImages() {
                    try {
                        const response = await fetch('carregar-imagem.php', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
                        });
                        const data = await response.json();

                        if (data.images) {
                            // Preenche o select com as imagens
                            const imageSelect = document.getElementById('imageSelect');
                            data.images.forEach(image => {
                                const option = document.createElement('option');
                                option.value = image.id;
                                option.textContent = image.descricao;
                                imageSelect.appendChild(option);
                            });
                        } else if (data.error) {
                            Swal.fire('Erro!', data.error, 'error');
                        } else {
                            Swal.fire('Erro!', 'Nenhuma imagem disponível.', 'error');
                        }
                    } catch (error) {
                        console.error('Erro ao carregar imagens:', error);
                        Swal.fire('Erro!', 'Erro ao obter a lista de imagens.', 'error');
                    }
                }
            });
























            document.getElementById('loadImages').addEventListener('click', function() {
                loadImageWithPrompt();
            });

            async function loadImageWithPrompt() {
                // Obtém a lista de imagens do servidor
                try {
                    const response = await fetch('carregar-imagem.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
                    });
                    const data = await response.json();

                    if (data.images) {
                        // Monta as opções para o select
                        const options = data.images.map(image => `<option value="${image.id}">${image.descricao}</option>`).join('');

                        // Exibe o SweetAlert2 com o select e o novo botão "Enviar imagem"
                        const { value: imageId } = await Swal.fire({
                            title: 'Carregar Imagem',
                            html: `
<select id="swal-input1" class="swal2-input">${options}</select>
<br><br>
<a href="criador-tema.html" class="swal2-styled swal2-cancel">Enviar imagem</a>
<!-- Ou, se preferir usar um botão:
<button onclick="window.location.href='criador-tema.html'" class="swal2-styled swal2-cancel">Enviar imagem</button>
-->
`,
                            focusConfirm: false,
                            showCancelButton: true,
                            confirmButtonText: 'Carregar',
                            preConfirm: () => {
                                const selectedId = document.getElementById('swal-input1').value;
                                if (!selectedId) {
                                    Swal.showValidationMessage('Por favor, selecione uma imagem!');
                                    return false;
                                }
                                return selectedId;
                            }
                        });

                        if (!imageId) return;

                        await attemptToLoadImage(imageId);
                    } else if (data.error) {
                        Swal.fire('Erro!', data.error, 'error');
                    } else {
                        Swal.fire('Erro!', 'Nenhuma imagem disponível.', 'error');
                    }
                } catch (error) {
                    console.error(error);
                    Swal.fire('Erro!', 'Erro ao obter a lista de imagens.', 'error');
                }
            }


            async function attemptToLoadImage(imageId) {
                const params = new URLSearchParams();
                params.append('id', imageId);

                try {
                    const response = await fetch('carregar-imagem.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: params.toString()
                    });
                    const data = await response.json();

                    if (data.url && data.bounds) {
                        var bounds = L.latLngBounds(data.bounds);
                        var imageLayer = L.imageOverlay(data.url, bounds);
                        addNewOverlayLayer(`Imagem: ${data.descricao}`, imageLayer);
                    } else if (data.error) {
                        if (data.error === 'Senha incorreta ou não fornecida.') {
                            // Solicita a senha
                            const { value: senhaInput } = await Swal.fire({
                                title: 'Senha necessária',
                                input: 'password',
                                inputPlaceholder: 'Digite a senha',
                                showCancelButton: true,
                                confirmButtonText: 'Carregar',
                                preConfirm: (value) => {
                                    if (!value) {
                                        Swal.showValidationMessage('A senha não pode estar vazia!');
                                        return false;
                                    }
                                    return value;
                                }
                            });
                            if (!senhaInput) return;

                            // Tenta carregar a imagem novamente com a senha fornecida
                            params.append('senha', senhaInput);

                            const responseWithPassword = await fetch('carregar-imagem.php', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                body: params.toString()
                            });
                            const dataWithPassword = await responseWithPassword.json();

                            if (dataWithPassword.url && dataWithPassword.bounds) {
                                var bounds = L.latLngBounds(dataWithPassword.bounds);
                                var imageLayer = L.imageOverlay(dataWithPassword.url, bounds);
                                addNewOverlayLayer(`Imagem: ${dataWithPassword.descricao}`, imageLayer);
                            } else if (dataWithPassword.error) {
                                // Informa que a senha está incorreta e encerra o processo
                                Swal.fire('Erro!', 'Senha incorreta.', 'error');
                            } else {
                                Swal.fire('Erro!', 'Imagem não encontrada ou dados incompletos.', 'error');
                            }
                        } else {
                            Swal.fire('Erro!', data.error, 'error');
                        }
                    } else {
                        Swal.fire('Erro!', 'Imagem não encontrada ou dados incompletos.', 'error');
                    }
                } catch (error) {
                    console.error(error);
                    Swal.fire('Erro!', 'Erro ao carregar a imagem.', 'error');
                }
            }








           document.getElementById('loadDrawings').addEventListener('click', async function() {
    const { value: usuario } = await Swal.fire({
        title: 'Insira seu usuário',
        input: 'text',
        inputPlaceholder: 'Digite o usuário',
        showCancelButton: true,
        cancelButtonText: 'Cancelar',
        confirmButtonText: 'Confirmar',
        inputValidator: (value) => {
            if (!value) {
                return 'Usuário é necessário para carregar os desenhos!';
            }
        }
    });

    if (!usuario) return; // Sai se o usuário cancelar ou não preencher

    const urlCompleta = window.location.href;
    const padraoDiretorio = /https:\/\/methodux\.online\/(.*?)\//;
    const resultado = padraoDiretorio.exec(urlCompleta);
    const diretorio = resultado ? resultado[1] : '';

    try {
        const response = await fetch("/carregar.php", {
            method: "POST",
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `usuario=${encodeURIComponent(usuario)}&link=${encodeURIComponent(diretorio)}`
        });

        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);

        const geoJsonData = await response.json();
        console.log("Geojson carregado:", geoJsonData);

        if (!isValidGeoJson(geoJsonData)) {
            Swal.fire('Erro', 'Erro ao carregar os desenhos. Verifique o usuário e o link!', 'error');
            return;
        }

        const { isConfirmed: escolha } = await Swal.fire({
            title: 'Como deseja carregar os desenhos?',
            text: "Escolha 'Edição' para edição ou 'Camada não-editável' para carregá-los como uma nova camada.",
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: 'Edição',
            cancelButtonText: 'Camada não-editável'
        });

        // Definição do cache de padrões
        var patternCache = {};

        // Função para criar ou obter um padrão existente
        function getPattern(fillPatternType, color) {
            var key = fillPatternType + '_' + color;
            if (patternCache[key]) {
                return patternCache[key];
            }
            let patternId = 'pattern_' + fillPatternType + '_' + color.replace('#', '');
            let pattern = new L.Pattern({
                id: patternId,
                width: 8,
                height: 8,
                patternUnits: 'userSpaceOnUse'
            });
            var shape;
            if (fillPatternType === 'patternX') {
                shape = new L.PatternPath({
                    d: 'M0,0 L8,8 M8,0 L0,8',
                    stroke: true,
                    weight: 1,
                    color: color
                });
            } else if (fillPatternType === 'patternSlash') {
                shape = new L.PatternPath({
                    d: 'M0,0 L8,8',
                    stroke: true,
                    weight: 1,
                    color: color
                });
            }
            pattern.addShape(shape);
            pattern.addTo(map);
            patternCache[key] = pattern;
            return pattern;
        }

        if (!escolha) {
            // Carrega como camada não-editável
            const newLayerName = usuario;
            const newLayer = L.geoJson(null).addTo(map);

            L.geoJson(geoJsonData, {
                onEachFeature: function(feature, layer) {
                    if (feature.geometry.type === 'Point' && Object.keys(feature.properties).length === 0) {
                        var emptyIcon = L.divIcon({ html: '', className: 'empty-icon', iconSize: [0, 0] });
                        layer.setIcon(emptyIcon);
                        newLayer.addLayer(layer);
                    } else if (feature.geometry.type === 'Point' && feature.properties.shape === 'circle') {
                        var newCircle = L.circle([feature.properties.center[0], feature.properties.center[1]], {
                            color: feature.properties.color,
                            fillColor: feature.properties.color,
                            fillOpacity: 0.5,
                            radius: feature.properties.radius
                        });
                        newLayer.addLayer(newCircle);
                    } else if (feature.properties.text && feature.geometry.type === 'Point' && !feature.properties.iconUrl) {
                        var customIcon = L.divIcon({
                            className: 'custom-text-label',
                            html: feature.properties.text,
                            iconSize: [100, 30],
                            iconAnchor: [15, 15]
                        });
                        layer.setIcon(customIcon);
                        newLayer.addLayer(layer);
                    } else if (feature.geometry.type === 'Point' && feature.properties.iconUrl) {
                        var customIcon = L.icon({
                            iconUrl: feature.properties.iconUrl,
                            iconSize: [40, 40],
                            iconAnchor: [15, 15]
                        });
                        layer.setIcon(customIcon);
                        newLayer.addLayer(layer);
                    } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'Polygon') {
                        // Modificação para aplicar estilos adicionais
                        let style = { color: feature.properties.color };

                        if (feature.properties.dashArray) {
                            style.dashArray = feature.properties.dashArray;
                        }

                        if (feature.geometry.type === 'Polygon') {
                            if (feature.properties.fillColor) {
                                style.fillColor = feature.properties.fillColor;
                                style.fillOpacity = feature.properties.fillOpacity || 0.5;
                            }
                            if (feature.properties.fillPattern) {
                                // Usar a função getPattern para obter o padrão correto
                                let pattern = getPattern(feature.properties.fillPattern, feature.properties.color);
                                style.fillPattern = pattern;
                            }
                        }

                        layer.setStyle(style);
                        newLayer.addLayer(layer);
                    }
                }
            });

            addNewOverlayLayer(newLayerName, newLayer);

        } else {
            // Carrega para edição
            drawnItems.clearLayers();

            L.geoJson(geoJsonData, {
                onEachFeature: function(feature, layer) {
                    if (feature.geometry.type === 'Point' && Object.keys(feature.properties).length === 0) {
                        var emptyIcon = L.divIcon({ html: '', className: 'empty-icon', iconSize: [0, 0] });
                        layer.setIcon(emptyIcon);
                        return;
                    } else if (feature.geometry.type === 'Point' && feature.properties.shape === 'circle') {
                        var newCircle = L.circle([feature.properties.center[0], feature.properties.center[1]], {
                            color: feature.properties.color,
                            fillColor: feature.properties.color,
                            fillOpacity: 0.5,
                            radius: feature.properties.radius
                        });
                        drawnItems.addLayer(newCircle);
                    } else if (feature.properties.text && feature.geometry.type === 'Point' && !feature.properties.iconUrl) {
                        var customIcon = L.divIcon({
                            className: 'custom-text-label',
                            html: feature.properties.text,
                            iconSize: [100, 30],
                            iconAnchor: [15, 15]
                        });
                        layer.setIcon(customIcon);
                        drawnItems.addLayer(layer);
                    } else if (feature.geometry.type === 'Point' && feature.properties.iconUrl) {
                        var customIcon = L.icon({
                            iconUrl: feature.properties.iconUrl,
                            iconSize: [40, 40],
                            iconAnchor: [15, 15]
                        });
                        layer.setIcon(customIcon);
                        drawnItems.addLayer(layer);
                    } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'Polygon') {
                        // Modificação para aplicar estilos adicionais
                        let style = { color: feature.properties.color };

                        if (feature.properties.dashArray) {
                            style.dashArray = feature.properties.dashArray;
                        }

                        if (feature.geometry.type === 'Polygon') {
                            if (feature.properties.fillColor) {
                                style.fillColor = feature.properties.fillColor;
                                style.fillOpacity = feature.properties.fillOpacity || 0.5;
                            }
                            if (feature.properties.fillPattern) {
                                // Usar a função getPattern para obter o padrão correto
                                let pattern = getPattern(feature.properties.fillPattern, feature.properties.color);
                                style.fillPattern = pattern;
                            }
                        }

                        layer.setStyle(style);
                        drawnItems.addLayer(layer);
                    }
                }
            }).addTo(map);
        }

        if (drawnItems.getLayers().length) {
            map.fitBounds(drawnItems.getBounds());
        }

    } catch (error) {
        console.error("Erro ao carregar desenhos:", error);
        Swal.fire('Erro HTTP', `Erro: ${error.message}`, 'error');
    }
           });




            map.createPane('pane_OpenTopo_0');
            map.getPane('pane_OpenTopo_0').style.zIndex = 100;
            var layer_OpenTopo_0 = L.tileLayer('https://tile.opentopomap.org/{z}/{x}/{y}.png', {
                pane: 'pane_OpenTopo_0',
                opacity: 1.0,
                attribution: '',
                minZoom: 1,
                maxZoom: 28,
                minNativeZoom: 0,
                maxNativeZoom: 18
            });
            layer_OpenTopo_0;
            map.addLayer(layer_OpenTopo_0);
            map.createPane('pane_GoogleSatellite_1');
            map.getPane('pane_GoogleSatellite_1').style.zIndex = 101;
            var layer_GoogleSatellite_1 = L.tileLayer('https://mt0.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}', {
                pane: 'pane_GoogleSatellite_1',
                opacity: 1.0,
                attribution: '',
                minZoom: 1,
                maxZoom: 28,
                minNativeZoom: 0,
                maxNativeZoom: 18
            });
            layer_GoogleSatellite_1;
            map.addLayer(layer_GoogleSatellite_1);


            map.createPane('pane_BDGEx_2');
            map.getPane('pane_BDGEx_2').style.zIndex = 104;
            var layer_BDGEx_2 = L.tileLayer.wms('https://bdgex.eb.mil.br/mapcache', {
                layers: 'ctm50',
                format: 'image/png',
                transparent: true,
                version: '1.1.1',
                tileSize: 96,
                crs: L.CRS.EPSG4326, // Ajustado para usar EPSG:4326
                dpiMode: 7,
                tileMatrixSet: 'ctm50-wmsc-2'
            });

            map.addLayer(layer_BDGEx_2);


            // Crie um pane para a camada OpenInfraMap
            map.createPane('pane_OpenInfraMap');
            map.getPane('pane_OpenInfraMap').style.zIndex = 1100; // Ajuste o zIndex conforme necessário

            // Defina a camada OpenInfraMap usando vector tiles
            var openInfraMapLayer = L.vectorGrid.protobuf('https://openinframap.org/tiles/{z}/{x}/{y}.pbf', {
                pane: 'pane_OpenInfraMap',
                minZoom: 2,
                maxZoom: 17,
                interactive: true, // Torna os elementos interativos
                rendererFactory: L.svg.tile, // Use o renderizador SVG
                vectorTileLayerStyles: {
                    // Linhas de energia
                    power_line: {
                        color: 'orange',
                        weight: 2,
                        opacity: 1.0,
                        interactive: true, // Adicionado
                    },
                    // Torres de energia
                    power_tower: {
                        fill: true,
                        fillColor: 'black',
                        fillOpacity: 1,
                        radius: 3,
                        interactive: true, // Adicionado
                    },
                    // Subestações
                    power_substation: {
                        fill: true,
                        fillColor: 'red',
                        fillOpacity: 0.8,
                        radius: 5,
                        interactive: true, // Adicionado
                    },
                    // Plantas de energia
                    power_plant: {
                        fill: true,
                        fillColor: 'green',
                        fillOpacity: 0.8,
                        radius: 5,
                        interactive: true, // Adicionado
                    },
                    // Geradores
                    power_generator: {
                        fill: true,
                        fillColor: 'blue',
                        fillOpacity: 0.8,
                        radius: 4,
                        interactive: true, // Adicionado
                    },
                    // Linhas de telecomunicação
                    telecoms_communication_line: {
                        color: 'purple',
                        weight: 2,
                        opacity: 1.0,
                        interactive: true, // Adicionado
                    },
                    // Masts de telecomunicação
                    telecoms_mast: {
                        fill: true,
                        fillColor: 'magenta',
                        fillOpacity: 0.8,
                        radius: 3,
                        interactive: true, // Adicionado
                    },
                    // Tubulações de petróleo
                    petroleum_pipeline: {
                        color: 'brown',
                        weight: 2,
                        opacity: 1.0,
                        interactive: true, // Adicionado
                    },
                    // Poços de petróleo
                    petroleum_well: {
                        fill: true,
                        fillColor: 'black',
                        fillOpacity: 1,
                        radius: 3,
                        interactive: true, // Adicionado
                    },
                    // Sites de petróleo
                    petroleum_site: {
                        fill: true,
                        fillColor: 'gray',
                        fillOpacity: 0.8,
                        radius: 5,
                        interactive: true, // Adicionado
                    },
                    // Tubulações de água
                    water_pipeline: {
                        color: 'blue',
                        weight: 2,
                        opacity: 0.7,
                        interactive: true, // Adicionado
                    },
                }
            });
            map.addLayer(openInfraMapLayer);

            // Inicializa a camada composta para as quadrículas UTM do Brasil
            var utmGrids = L.layerGroup();

            // Adiciona cada zona UTM à camada composta
            utmGrids.addLayer(L.utmGrid(19, true, {
                color: '#080',
                showAxisLabels: [100, 1000, 10000, 100000],
                showSquareLabels: [100000], // label 100km grid squares
                showAxis100km: true
            }));
            utmGrids.addLayer(L.utmGrid(20, true, {
                color: '#800',
                showAxisLabels: [100, 1000, 10000, 100000],
                showSquareLabels: [100000], // label 100km grid squares
                showAxis100km: true
            }));
            utmGrids.addLayer(L.utmGrid(21, true, {
                color: '##880',
                showAxisLabels: [100, 1000, 10000, 100000],
                showSquareLabels: [100000], // label 100km grid squares
                showAxis100km: true
            }));
            utmGrids.addLayer(L.utmGrid(22, true, {
                color: '#008',
                showAxisLabels: [100, 1000, 10000, 100000],
                showSquareLabels: [100000], // label 100km grid squares
                showAxis100km: true
            }));

            utmGrids.addLayer(L.utmGrid(23, true, {
                color: '#080',
                showAxisLabels: [100, 1000, 10000, 100000],
                showSquareLabels: [100000], // label 100km grid squares
                showAxis100km: true
            }));

            utmGrids.addLayer(L.utmGrid(24, true, {
                color: '#800',
                showAxisLabels: [100, 1000, 10000, 100000],
                showSquareLabels: [100000], // label 100km grid squares
                showAxis100km: true
            }));

            utmGrids.addLayer(L.utmGrid(25, true, {
                color: '#880',
                showAxisLabels: [100, 1000, 10000, 100000],
                showSquareLabels: [100000], // label 100km grid squares
                showAxis100km: true
            }));

            // Adiciona a camada composta ao mapa
            map.addLayer(utmGrids);








            var baseMaps = {};
            //L.control.layers(baseMaps,{"Tema Escola": layer_Calcotemaescola_0,"Carta": layer_Carta_3,"BDGEx - CTM50": layer_BDGEx_2,"BDGEx - Relevo": layer_MultiescalaRelevo,"Google Satellite": layer_GoogleSatellite_1,"OpenTopo": layer_OpenTopo_0,},{collapsed:false}).addTo(map);
            setBounds();
            L.ImageOverlay.include({
                getBounds: function () {
                    return this._bounds;
                }
            });
            var planejamentoLayer = L.featureGroup().addTo(map);

            var layerControl; // Referência global ao controle de camadas
            var layerRegistry = {
                "OpenTopo": layer_OpenTopo_0,
                "Google Satellite": layer_GoogleSatellite_1,
                "Infraestruturas": openInfraMapLayer,
                "Quadrículas - UTM": utmGrids,
                "BDGEx - CTM50": layer_BDGEx_2,
                "Sugestão de Planejamento": planejamentoLayer
            };

            // Inicializa o controle de camadas uma vez
            var layerControl = L.control.layers(baseMaps, layerRegistry, {collapsed: false}).addTo(map);

            // Acessa o contêiner do controle de camadas
            var layerControlElement = layerControl.getContainer();

            // Cria um elemento div para conter os botões
            var buttonsDiv = L.DomUtil.create('div', 'layer-control-buttons', layerControlElement);
            buttonsDiv.style.marginTop = '10px'; // Ajuste o espaçamento conforme necessário

            // Insere os botões de Adicionar e Remover Camadas
            buttonsDiv.innerHTML += `
<i id="addLayerButton" class="fas fa-plus-square toolbar-icon" title="Adicionar Camadas" style="cursor: pointer; margin-right: 5px;"></i>
<i id="removeLayerButton" class="fas fa-minus-square toolbar-icon" title="Remover Camadas" style="cursor: pointer;"></i>
<i id="savePlanningButton" class="fas fa-save toolbar-icon" title="Salvar Sugestão de Planejamento" style="cursor: pointer;"></i>
<i id="startUpdateButton" class="fas fa-sync-alt toolbar-icon" title="Inserir camada atualizável" style="cursor: pointer; margin-left: 5px;"></i>
`;

            // Impede que cliques nos botões interfiram com as interações do mapa
            L.DomEvent.disableClickPropagation(buttonsDiv);
            L.DomEvent.on(buttonsDiv, 'mousedown dblclick click', L.DomEvent.stopPropagation);


            function deselecionarCamadasIniciais() {
                // Lista das camadas a serem removidas (exceto OpenTopo)
                var camadasParaRemover = [
                    layer_GoogleSatellite_1,
                    layer_BDGEx_2,
                    openInfraMapLayer,
                    utmGrids,
                    planejamentoLayer
                ];

                camadasParaRemover.forEach(function(camada) {
                    if (map.hasLayer(camada)) {
                        map.removeLayer(camada);
                    }
                });

                // Garantir que apenas OpenTopo esteja visível
                if (!map.hasLayer(layer_OpenTopo_0)) {
                    map.addLayer(layer_OpenTopo_0);
                }

                // Atualizar o controle de camadas para refletir o estado atual
                if (layerControl) {
                    layerControl._update();
                }
            }

            // Chame a função após a inicialização do mapa e das camadas
            deselecionarCamadasIniciais();


            function addNewOverlayLayer(layerName, layer) {
                // Verifica se o nome da camada já existe no registro
                if (!layerRegistry.hasOwnProperty(layerName)) {
                    layerRegistry[layerName] = layer; // Adiciona a nova camada ao registro

                    // Adiciona a camada ao controle de camadas existente
                    layerControl.addOverlay(layer, layerName);

                    // Opcionalmente, adiciona a camada ao mapa
                    map.addLayer(layer);
                } else {
                    console.warn(`A camada "${layerName}" já existe e não será adicionada novamente.`);
                }
            }

            


            // Função para preencher o seletor com os layers disponíveis e inicializar o registro de camadas
            function fillLayerSelector() {
                var layerRegistry = { // Variáveis de camadas declaradas diretamente
                    "OpenTopo": layer_OpenTopo_0,
                    "Google Satellite": layer_GoogleSatellite_1,
                    "BDGEx - CTM50": layer_BDGEx_2
                };

                var layerSelector = document.getElementById('layerSelector');
                layerSelector.innerHTML = ""; // Limpa o seletor antes de preenchê-lo

                // Adiciona opções ao seletor
                Object.keys(layerRegistry).forEach(function(key) {
                    var option = new Option(key, key);
                    layerSelector.appendChild(option);
                });

                return layerRegistry; // Retorna o registro para uso posterior
            }

            // Inicializa o layerRegistry a partir de fillLayerSelector
            var layers = fillLayerSelector();

            // Função para ajustar a transparência do layer selecionado
            function adjustLayerTransparency() {

                var selectedLayerKey = document.getElementById('layerSelector').value;
                var sliderValue = document.getElementById('transparencySlider').value;
                var opacity = parseFloat(sliderValue) / 100;

                if (selectedLayerKey && layers[selectedLayerKey]) {
                    var layer = layers[selectedLayerKey];

                    // Log detalhado do tipo e propriedades da camada
                    console.log('Tipo de camada:', layer.constructor.name);
                    console.log('Propriedades da camada:', layer);

                    // Ajuste de opacidade com métodos apropriados
                    if (typeof layer.setOpacity === 'function') {
                        layer.setOpacity(opacity);
                    } else if (layer.setStyle) {
                        layer.setStyle({ opacity: opacity, fillOpacity: opacity });
                    } else if (layer._container) {
                        layer._container.style.opacity = opacity;
                    } else {
                        console.warn(`O layer "${selectedLayerKey}" não suporta ajuste de opacidade.`);
                    }
                } else {
                    console.log(`selectedLayerKey ${selectedLayerKey} não encontrado no layerRegistry`);
                }
            }

            // Event listeners
            document.getElementById('layerSelector').addEventListener('change', adjustLayerTransparency);
            document.getElementById('transparencySlider').addEventListener('input', adjustLayerTransparency);



            // botão de fechar perfil topográfico
            document.getElementById('close-btn').addEventListener('click', function() {
                // Para fechar
                document.getElementById('elevation-profile-container').style.display = 'none';
            });


            //Perfil topográfico

            L.DomEvent.on(document, 'DOMContentLoaded', function () {

                var elevationProfileControl = L.control({position: 'topright'}); // Você pode ajustar a posição conforme necessário

                elevationProfileControl.onAdd = function(map) {
                    // Retorna o elemento que você quer adicionar ao mapa
                    // Neste caso, é o contêiner do perfil de elevação
                    var container = L.DomUtil.get('elevation-profile-container');
                    L.DomEvent.disableClickPropagation(container); // Impede que os cliques no contêiner afetem o mapa
                    return container;
                }



                // Adiciona o controle personalizado ao mapa
                elevationProfileControl.addTo(map);
            });
            function haversine(lat1, lon1, lat2, lon2) {
                function toRadians(degrees) {
                    return degrees * Math.PI / 180;
                }

                var earthRadius = 6371e3; // metros
                var lat1Rad = toRadians(lat1);
                var lat2Rad = toRadians(lat2);
                var deltaLatRad = toRadians(lat2 - lat1);
                var deltaLonRad = toRadians(lon2 - lon1);

                var a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) +
                    Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                    Math.sin(deltaLonRad / 2) * Math.sin(deltaLonRad / 2);
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                var d = earthRadius * c;
                return d;
            }


            async function getElevationProfile(marker1, marker2) {
                try {
                    // Extrai as localizações dos marcadores passados como argumentos
                    console.log(marker1);
                    var P1 = marker1.getLatLng();
                    var P2 = marker2.getLatLng();
                    var midpoint = {
                        lat: (P1.lat + P2.lat) / 2,
                        lng: (P1.lng + P2.lng) / 2
                    };

                    var s = 100; // Número de pontos
                    var interval_lat = (P2.lat - P1.lat) / s;
                    var interval_lon = (P2.lng - P1.lng) / s;

                    var points = []; // Array para armazenar os pontos gerados

                    // Gera os pontos intermediários entre os dois marcadores
                    for (var i = 0; i <= s; i++) {
                        var lat = P1.lat + (interval_lat * i);
                        var lng = P1.lng + (interval_lon * i);
                        points.push({ latitude: lat, longitude: lng });
                    }

                    console.log("Calculando perfil de elevação para os pontos:", points);

                    // Prepara os dados para enviar à API local
                    var payload = {
                        points: points
                    };

                    var json_data = JSON.stringify(payload);

                    // Faz a requisição POST para a API local elevation_profile.php
                    const response = await fetch('elevation_profile.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'applicationjson',
                        },
                        body: json_data,
                    });

                    if (!response.ok) {
                        throw new Error('Erro na resposta da API: ' + response.statusText);
                    }

                    const data = await response.json();

                    console.log("Dados de elevação recebidos:", data);

                    // Verifica se a resposta contém as elevações
                    if (!data || !Array.isArray(data)) {
                        throw new Error('Formato de dados inválido recebido da API.');
                    }

                    var elevationData = data.map(point => point.elevation);
                    drawElevationProfile(elevationData, midpoint); // Passa o ponto médio para a função
                } catch (error) {
                    console.error('Erro:', error);
                    Swal.fire({
                        icon: 'error',
                        title: 'Erro',
                        text: 'Ocorreu um erro ao obter o perfil de elevação.',
                    });
                }
            };



            async function loadImageFromId(calco) {
                if (!calco) {
                    console.error("IDs das imagens são necessários para carregar.");
                    return;
                }

                // Separar os IDs das imagens por vírgula
                const calcoArray = calco.split(',');

                for (const id of calcoArray) {
                    try {
                        // Primeiro, fazer uma requisição GET para obter a descrição e verificar se a imagem requer senha
                        let response = await fetch(`carregar-imagem.php?id=${id.trim()}`);
                        let data = await response.json();

                        if (data.error) {
                            console.error("Erro: " + data.error);
                            continue;
                        }

                        const descricao = data.descricao;
                        const requiresPassword = data.requiresPassword;

                        if (requiresPassword) {
                            // Solicita a senha
                            const { value: senha } = await Swal.fire({
                                title: `A imagem "${descricao}" requer uma senha`,
                                input: 'password',
                                inputPlaceholder: 'Digite a senha',
                                showCancelButton: true
                            });

                            if (!senha) {
                                Swal.fire('Erro!', 'Nenhuma senha foi fornecida.', 'error');
                                continue;
                            }

                            // Agora fazer o POST com a senha
                            const params = new URLSearchParams();
                            params.append('id', id.trim());
                            params.append('senha', senha);

                            response = await fetch('carregar-imagem.php', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                body: params.toString()
                            });

                        } else {
                            // Se não requer senha, fazer o POST sem a senha
                            const params = new URLSearchParams();
                            params.append('id', id.trim());

                            response = await fetch('carregar-imagem.php', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                body: params.toString()
                            });
                        }

                        const imageData = await response.json();

                        if (imageData.url && imageData.bounds) {
                            var bounds = L.latLngBounds(imageData.bounds);
                            var imageLayer = L.imageOverlay(imageData.url, bounds, { opacity: 0.7 });
                            addNewOverlayLayer(`${imageData.descricao}`, imageLayer);
                            console.log(`Imagem "${descricao}" carregada com sucesso.`);
                        } else if (imageData.error) {
                            Swal.fire('Erro', imageData.error, 'error');
                        } else {
                            console.error("Imagem não encontrada ou dados incompletos.");
                        }

                    } catch (error) {
                        console.error('Erro ao carregar a imagem:', error);
                    }
                }
            }






            var currentChart = null;

            function drawElevationProfile(elevationData, midpoint) {
                var container = document.getElementById('elevation-profile-container');
                container.style.display = 'block'; // Altera o display para 'block', tornando-o visível

                var canvas = document.getElementById('elevation-profile-canvas');
                var ctx = canvas.getContext('2d');

                if (currentChart != null) {
                    currentChart.destroy();
                }

                var startElevation = elevationData[0] + 12;
                var endElevation = elevationData[elevationData.length - 1] + 12;

                // Gerando um conjunto de dados para a linha reta ajustada
                var straightLineDataPoints = new Array(elevationData.length);
                straightLineDataPoints.fill(startElevation, 0, 1); // Ajuste inicial
                straightLineDataPoints.fill(endElevation, elevationData.length - 1); // Ajuste final

                // Ajustando os pontos intermediários para manter a linha reta no nível de elevação ajustado
                for (let i = 1; i < elevationData.length - 1; i++) {
                    let proportion = i / (elevationData.length - 1);
                    straightLineDataPoints[i] = startElevation + (endElevation - startElevation) * proportion;
                }

                var labels = elevationData.map((_, i) => (i + 1).toString());

                var lineData = {
                    label: 'Linha de alturas (m)',
                    backgroundColor: 'rgb(255, 99, 132)',
                    borderColor: 'rgb(255, 99, 132)',
                    data: elevationData,
                    fill: false,
                };

                var straightLineData = {
                    label: 'Enlace c/ torre 12m',
                    borderColor: 'rgb(0, 0, 255)',
                    data: straightLineDataPoints,
                    fill: false,
                    borderDash: [5, 5],
                };

                var data = {
                    labels: labels,
                    datasets: [lineData, straightLineData],
                };

                var config = {
                    type: 'line',
                    data: data,
                    options: {
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: 'blue', // Cor dos textos da legenda
                                }
                            },
                            title: {
                                display: true,
                                text: 'Perfil Topográfico', // Texto do título
                                font: {
                                    size: 18 // Tamanho da fonte do título
                                },
                                color: '#000', // Cor do título
                                padding: {
                                    top: 10,
                                    bottom: 30
                                }
                            },
                            background: {
                                color: 'rgba(255, 255, 255, 0.8)', // Fundo levemente branco com um pouco de transparência
                            }
                        },
                        maintainAspectRatio: false
                    },
                    scales: {
                        y: {
                            display: true,
                            beginAtZero: false,
                        },
                        x: { display: false }
                    },
                    plugins: [{
                        id: 'background', // Define a ID do plugin para correspondência com a configuração acima
                        beforeDraw: (chart) => {
                            const ctx = chart.ctx;
                            ctx.save();
                            ctx.globalCompositeOperation = 'destination-over';
                            ctx.fillStyle = chart.options.plugins.background.color;
                            ctx.fillRect(0, 0, chart.width, chart.height);
                            ctx.restore();
                        }
                    }]
                };

                canvas.height = 200; // Ajusta a altura do elemento canvas, não o estilo
                currentChart = new Chart(ctx, config);
            }



            var profileMarkers = [];
            drawnItems.on('layerremove', function(event) {
                var removedLayer = event.layer;
                profileMarkers = profileMarkers.filter(function(marker) {
                    return marker !== removedLayer;
                });
            });

            function delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }



            // Geolocalização do usuário
            var userMarker; // Variável global para o marcador da localização do usuário
            var trackingActive = false; // Estado inicial do rastreamento

            // Função chamada quando a localização do usuário é encontrada
            function onLocationFound(e) {
                var radius = e.accuracy / 2; // A precisão da localização em metros

                if (userMarker) {
                    map.removeLayer(userMarker); // Remove o marcador anterior, se existir
                }

                userMarker = L.marker(e.latlng).addTo(map); // Adiciona um novo marcador na localização do usuário

                //map.setView(e.latlng, 13); // Centraliza o mapa na localização do usuário com zoom 13
            }

            // Função de callback para quando a localização não pode ser obtida
            function onLocationError(e) {
                alert("Erro ao obter a localização: " + e.message);
            }

            // Função para iniciar ou parar o rastreamento
            function toggleLocationTracking() {
                if (!trackingActive) {
                    // Inicia o rastreamento
                    map.on('locationfound', onLocationFound);
                    map.on('locationerror', onLocationError);
                    map.locate({setView: true, maxZoom: 16, watch: true, enableHighAccuracy: true});
                    trackingActive = true; // Atualiza o estado do rastreamento
                } else {
                    // Para o rastreamento
                    map.stopLocate(); // Para de rastrear a localização do usuário
                    map.off('locationfound', onLocationFound); // Remove o listener do evento de localização encontrada
                    map.off('locationerror', onLocationError); // Remove o listener do evento de erro de localização
                    if (userMarker) {
                        map.removeLayer(userMarker); // Remove o marcador da localização do usuário
                        userMarker = null;
                    }
                    trackingActive = false; // Atualiza o estado do rastreamento
                }
            }

            // Adiciona um ouvinte de eventos ao botão
            document.getElementById('locateMeButton').addEventListener('click', toggleLocationTracking);






            // Adiciona um ouvinte de evento ao botão de exportação para KMZ
            document.getElementById('exportKMZ').addEventListener('click', exportDrawingsToKMZ);



            async function exportDrawingsToKMZ() {
                try {
                    console.log("Iniciando a exportação para KMZ...");

                    // Obtém os dados dos desenhos existentes
                    var geoJsonData = drawnItems.toGeoJSON();
                    console.log("geoJsonData inicial:", geoJsonData);

                    // Verifica as chaves presentes em layerRegistry
                    console.log("Chaves em layerRegistry:", Object.keys(layerRegistry));

                    // Verifica se a camada "Sugestão de Planejamento" existe no layerRegistry
                    if (layerRegistry.hasOwnProperty("Sugestão de Planejamento")) {
                        console.log("A camada 'Sugestão de Planejamento' está presente no layerRegistry.");
                        var sugestaoLayer = layerRegistry["Sugestão de Planejamento"];
                        console.log("sugestaoLayer:", sugestaoLayer);

                        // Verifica se a camada possui layers internos
                        if (sugestaoLayer.getLayers && sugestaoLayer.getLayers().length > 0) {
                            console.log("'Sugestão de Planejamento' possui layers:", sugestaoLayer.getLayers().length);

                            // Obtém os dados da camada "Sugestão de Planejamento"
                            var sugestaoGeoJSON = sugestaoLayer.toGeoJSON();
                            console.log("sugestaoGeoJSON:", sugestaoGeoJSON);

                            // Verifica se há features no GeoJSON
                            if (sugestaoGeoJSON.features && sugestaoGeoJSON.features.length > 0) {
                                console.log("sugestaoGeoJSON possui features:", sugestaoGeoJSON.features.length);

                                // Adiciona uma propriedade 'folderName' para agrupar em uma pasta
                                sugestaoGeoJSON.features.forEach(feature => {
                                    feature.properties.folderName = "Sugestão de Planejamento";
                                    // Garantir que cada feature tenha 'name' e 'description'
                                    feature.properties.name = feature.properties.name || "";
                                    feature.properties.description = feature.properties.description || "";
                                });

                                // Combina as features dos desenhos com as da camada "Sugestão de Planejamento"
                                geoJsonData.features = geoJsonData.features.concat(sugestaoGeoJSON.features);
                                console.log("Após concatenação, geoJsonData.features.length:", geoJsonData.features.length);
                            } else {
                                console.log("sugestaoGeoJSON não possui features.");
                            }
                        } else {
                            console.log("'Sugestão de Planejamento' não possui layers ou getLayers() não está disponível.");
                        }
                    } else {
                        console.log("A camada 'Sugestão de Planejamento' NÃO está presente no layerRegistry.");
                    }

                    console.log("geoJsonData final:", geoJsonData);

                    // Função para inserir o Folder "Sugestão de Planejamento" no KML
                    function insertFolderIntoKML(kmlString, folderName) {
                        const parser = new DOMParser();
                        const serializer = new XMLSerializer();
                        const xmlDoc = parser.parseFromString(kmlString, "application/xml");

                        // Cria o elemento Folder
                        const folder = xmlDoc.createElement("Folder");

                        // Adiciona o nome do Folder
                        const nameElem = xmlDoc.createElement("name");
                        nameElem.textContent = folderName;
                        folder.appendChild(nameElem);

                        // Seleciona todas as Placemarks que pertencem ao Folder
                        const placemarks = xmlDoc.getElementsByTagName("Placemark");
                        const placemarksToMove = [];

                        for (let placemark of placemarks) {
                            const description = placemark.getElementsByTagName("description")[0]?.textContent || "";
                            if (description.includes(folderName)) {
                            placemarksToMove.push(placemark);
                            }
                            }

                            // Move as Placemarks para o Folder
                            placemarksToMove.forEach(placemark => {
                            folder.appendChild(placemark);
                            });

                            // Remove as Placemarks movidas do Document original
                            placemarksToMove.forEach(placemark => {
                            placemark.parentNode.removeChild(placemark);
                            });

                            // Adiciona o Folder ao Document
                            const documentElem = xmlDoc.getElementsByTagName("Document")[0];
                            documentElem.appendChild(folder);

                            // Serializa o XML de volta para string
                            return serializer.serializeToString(xmlDoc);
                            }

                            // Converte GeoJSON para KML com suporte para ícones e estilos usando geojsontokml
                            var kmlData = geojsontokml(geoJsonData, {
                            name: 'name',
                                  description: 'description',
                                      documentName: 'A Escola da Tatica',
                                          documentDescription: 'KMZ exportado por escoladatatica.fun',
                                              folderName: function(properties) {
                                                  return properties.folderName || 'Outras Features';
                                              }
                        });

                        // Define as tags de início e fim do Folder
                        const folderStartTag = `<Folder><name>Sugestão de Planejamento</name>`;
                        const folderEndTag = `</Folder>`;

                        // Expressão regular para encontrar todos os Placemark
                        const placemarkRegex = /<Placemark>[\s\S]*?<\/Placemark>/g;
                        const allPlacemarks = kmlData.match(placemarkRegex);

                        // Filtrar os Placemarks que pertencem à "Sugestão de Planejamento"
                        const folderPlacemarks = allPlacemarks.filter(placemark => placemark.includes('<name>Conexão TAR</name>') || placemark.includes('<name>NA Sugerido</name>')|| placemark.includes('<name>Enlace Sugerido</name>')|| placemark.includes('<name>EIR Sugerido</name>')|| placemark.includes('<name>CN Sugerido</name>') || placemark.includes('<name>TAR Sugerido</name>') || placemark.includes('<name>Cobertura TAR</name>'));

                        // Remover os Placemarks da "Sugestão de Planejamento" do kmlData original
                        folderPlacemarks.forEach(placemark => {
                            kmlData = kmlData.replace(placemark, '');
                        });

                        // Criar a seção do Folder com os Placemarks filtrados
                        const folderKml = `${folderStartTag}\n${folderPlacemarks.join('\n')}\n${folderEndTag}`;

                        // Inserir o Folder no KML antes do fechamento de </Document>
                        kmlData = kmlData.replace('</Document>', `${folderKml}\n</Document>`);

                        // Continua com a criação do ZIP e download
                        console.log("kmlData com Folder inserido:", kmlData);
                        var zip = new JSZip();
                        zip.file("doc.kml", kmlData);
                        console.log("Arquivo 'doc.kml' adicionado ao ZIP.");

                        // Pergunta ao usuário se ele deseja adicionar imagens da camada atual
                        const result = await Swal.fire({
                            title: 'Adicionar Imagens ao KMZ?',
                            text: 'Você deseja adicionar imagens da camada atual, como as cartas do BDGEx? Isso pode aumentar o tamanho do arquivo.',
                            icon: 'question',
                            showCancelButton: true,
                            confirmButtonText: 'Sim, adicionar',
                            cancelButtonText: 'Não, obrigado'
                        });

                        if (result.isConfirmed) {
                            console.log("Usuário escolheu adicionar imagens da camada BDGEx.");
                            await addBDGExLayerToKMZ(zip);
                        }

                        // Baixa os ícones necessários, converte para PNG e adiciona ao zip
                        var uniqueIcons = [...new Set(geoJsonData.features.map(f => f.properties.iconUrl).filter(Boolean))];
                        console.log("uniqueIcons:", uniqueIcons);

                        await Promise.all(uniqueIcons.map(async (iconUrl) => {
                            try {
                                console.log("Processando ícone:", iconUrl);
                                const response = await fetch(iconUrl);
                                if (!response.ok) {
                                    throw new Error(`Failed to fetch ${iconUrl}`);
                                }
                                const iconBlob = await response.blob();
                                const iconName = iconUrl.split('/').pop().replace(/\.\w+$/, '.png');
                                console.log("iconName:", iconName);

                                // Converte a imagem para PNG
                                const img = document.createElement('img');
                                img.src = URL.createObjectURL(iconBlob);
                                await new Promise((resolve, reject) => {
                                    img.onload = () => resolve();
                                    img.onerror = (err) => reject(err);
                                });

                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                ctx.drawImage(img, 0, 0);

                                const pngBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                                zip.file(`files/${iconName}`, pngBlob);
                                console.log(`Ícone ${iconName} adicionado ao KMZ.`);
                            } catch (error) {
                                console.error('Erro ao processar o ícone:', error);
                            }
                        }));

                        // Gera o arquivo KMZ e faz o download
                        try {
                            const content = await zip.generateAsync({ type: "blob" });
                            var link = document.createElement("a");
                            link.href = URL.createObjectURL(content);
                            link.download = "aescoladatatica.kmz";
                            link.click();
                            console.log("KMZ gerado e download iniciado.");
                        } catch (error) {
                            console.error("Erro ao gerar o KMZ:", error);
                        }
                    } catch (error) {
                        console.error("Erro na função exportDrawingsToKMZ:", error);
                    }
                }







                async function addBDGExLayerToKMZ(zip) {
                    // Utiliza SweetAlert2 para a escolha da qualidade
                    const { value: qualityOption } = await Swal.fire({
                        title: 'Escolha a Qualidade da Imagem',
                        text: 'Selecione a qualidade desejada para exportar as imagens.',
                        icon: 'question',
                        input: 'select',
                        inputOptions: {
                            high: 'Alta Qualidade (1m30s - 10MB)',
                            medium: 'Média Qualidade (40s - 5MB)',
                            low: 'Baixa Qualidade (20s - 2,5MB)'
                        },
                        inputPlaceholder: 'Selecione uma qualidade',
                        showCancelButton: true,
                        confirmButtonText: 'Confirmar',
                        cancelButtonText: 'Cancelar'
                    });

                    // Define o número de divisões com base na escolha de qualidade
                    let divisions;
                    switch (qualityOption) {
                        case 'high':
                            divisions = 4; // Alta Qualidade: 4 divisões
                            break;
                        case 'medium':
                            divisions = 3; // Média Qualidade: 3 divisões
                            break;
                        case 'low':
                            divisions = 2; // Baixa Qualidade: 2 divisões
                            break;
                        default:
                            return; // Se o usuário cancelar, a função é encerrada
                                         }

                    const panels = [];
                    const mapElement = document.getElementById('map');
                    const originalZoom = map.getZoom();
                    const targetZoom = originalZoom + 2;
                    const bounds = map.getBounds();
                    const { north, south, east, west } = {
                        north: bounds.getNorth(),
                        south: bounds.getSouth(),
                        east: bounds.getEast(),
                        west: bounds.getWest()
                    };

                    const width = mapElement.offsetWidth;
                    const height = mapElement.offsetHeight;

                    const latStep = (north - south) / divisions;
                    const lonStep = (east - west) / divisions;

                    for (let i = 0; i < divisions; i++) {
                        for (let j = 0; j < divisions; j++) {
                            const panelNorth = north - i * latStep;
                            const panelSouth = north - (i + 1) * latStep;
                            const panelWest = west + j * lonStep;
                            const panelEast = west + (j + 1) * lonStep;
                            panels.push([[panelNorth, panelWest], [panelSouth, panelEast]]);
                        }
                    }

                    const images = [];
                    const elementsToHide = document.querySelectorAll('.leaflet-control, .leaflet-top, .leaflet-bottom, .leaflet-interactive');

                    // Oculta os elementos do Leaflet
                    elementsToHide.forEach(element => element.style.display = 'none');

                    // Garante que os elementos de texto estejam visíveis
                    const textElements = document.querySelectorAll('.custom-text-label');
                    textElements.forEach(element => element.style.display = 'block');

                    let cancelCapture = false; // Variável para controlar o cancelamento

                    // Configura a barra de progresso com SweetAlert2 e um botão de cancelamento
                    Swal.fire({
                        title: 'Capturando Imagens',
                        html: 'Progresso: <b>0%</b>',
                        icon: 'info',
                        allowOutsideClick: false,
                        showCancelButton: true, // Habilita o botão de cancelamento
                        cancelButtonText: 'Cancelar',
                        showConfirmButton: false, // Remove o botão de confirmação para evitar confusão
                        willOpen: () => {
                            Swal.showLoading();
                            // Listener para o botão de cancelar
                            Swal.getCancelButton().addEventListener('click', () => {
                                isCancelled = true;
                                elementsToHide.forEach(element => element.style.display = ''); // Restaura os controles do mapa
                                Swal.close();
                            });
                        }
                    });


                    for (let index = 0; index < panels.length; index++) {
                        if (cancelCapture) break; // Verifica se o usuário cancelou

                        const panel = panels[index];
                        map.fitBounds(panel);
                        await new Promise(resolve => setTimeout(resolve, 5000)); // Aguarda o ajuste do mapa

                        const canvas = await html2canvas(mapElement, {
                            useCORS: true,
                            width: width,
                            height: height,
                            backgroundColor: null
                        });

                        images.push(canvas);

                        // Atualiza a barra de progresso
                        const progress = Math.round(((index + 1) / panels.length) * 100);
                        Swal.getHtmlContainer().querySelector('b').textContent = `${progress}%`;
                    }

                    if (cancelCapture) {
                        // Reexibe os elementos e restaura o zoom original caso o usuário cancele
                        elementsToHide.forEach(element => element.style.display = '');
                        map.setZoom(originalZoom);
                        map.fitBounds(bounds);
                        Swal.fire('Operação Cancelada', 'A captura das imagens foi cancelada.', 'info');
                        return;
                    }

                    // Exibe novamente os elementos do Leaflet
                    elementsToHide.forEach(element => element.style.display = '');

                    // Restaura o zoom original do mapa
                    map.setZoom(originalZoom);
                    map.fitBounds(bounds);

                    // Unir as imagens capturadas em uma única imagem
                    const finalCanvas = document.createElement('canvas');
                    finalCanvas.width = width * divisions;
                    finalCanvas.height = height * divisions;
                    const finalCtx = finalCanvas.getContext('2d');

                    images.forEach((canvas, index) => {
                        const row = Math.floor(index / divisions);
                        const col = index % divisions;
                        const x = col * width;
                        const y = row * height;
                        finalCtx.drawImage(canvas, x, y, width, height);
                    });

                    const jpegBlob = await new Promise(resolve => finalCanvas.toBlob(resolve, 'image/jpeg', 0.95));

                    // Adiciona a imagem ao zip
                    const imageName = 'BDGEx_CTM50.jpg';
                    zip.file(`files/${imageName}`, jpegBlob);

                    // Cria a entrada GroundOverlay para o KML
                    const groundOverlay = `
<GroundOverlay>
<name>Carta BDGEx</name>
<visibility>0</visibility>
<Icon>
<href>files/${imageName}</href>
<viewBoundScale>0.75</viewBoundScale>
            </Icon> 
<LatLonBox>
<north>${north}</north>
<south>${south}</south>
<east>${east}</east>
<west>${west}</west>
            </LatLonBox>
            </GroundOverlay>`;

                    // Adiciona o GroundOverlay ao KML existente
                    const kmlData = await zip.file("doc.kml").async("string");
                    const newKmlData = kmlData.replace('</Document>', `${groundOverlay}</Document>`);
                    zip.file("doc.kml", newKmlData);

                    // Fecha o SweetAlert2 ao finalizar
                    Swal.close();
                }















                function geojsontokml(geojson, options) {
                    const kmlHeader = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
<name>${options.documentName}</name>
<description>${options.documentDescription}</description>`;

                    const kmlFooter = `</Document></kml>`;

                    function adjustColorOpacity(hex, opacity) {
                        const alpha = Math.round(opacity * 255).toString(16).padStart(2, '0');
                        const red = hex.slice(1, 3);
                        const green = hex.slice(3, 5);
                        const blue = hex.slice(5, 7);
                        return alpha + blue + green + red; // AABBGGRR
                    }

                    function stripHTML(html) {
                        let tmp = document.createElement("DIV");
                        tmp.innerHTML = html;
                        return tmp.textContent || tmp.innerText || "";
                    }

                    function createPlacemark(feature) {
                        const geometryType = feature.geometry.type;
                        const coordinates = feature.geometry.coordinates;
                        const properties = feature.properties;
                        const iconUrl = properties.iconUrl ? `files/${properties.iconUrl.split('/').pop().replace(/\.\w+$/, '.png')}` : '';
                        const styleUrl = iconUrl ? `<styleUrl>#m_${iconUrl}</styleUrl>` : '';
                        const color = properties.color ? adjustColorOpacity(properties.color, 1.0) : 'ff000000';
                        const fillColor = properties.color ? adjustColorOpacity(properties.color, 0.6) : '99000000';
                        const lineColor = properties.color ? adjustColorOpacity(properties.color, 1.0) : 'ff000000';

                        if (geometryType === "Point") {
                            const textContent = properties.text ? stripHTML(properties.text) : '';
                            if (textContent) {
                                return `<Placemark>
<name>${textContent}</name>
<description>${properties.description || ''}</description>
<Style>
<IconStyle>
<Icon>
<href></href>
            </Icon>
            </IconStyle>
<LabelStyle>
<color>ff000000</color>
<scale>1</scale>
            </LabelStyle>
            </Style>
<Point>
<coordinates>${coordinates.join(',')}</coordinates>
            </Point>
            </Placemark>`;
                            } else {
                                return `<Placemark>
<name>${properties.name || ''}</name>
<description>${properties.description || ''}</description>
${styleUrl}
<Point>
<coordinates>${coordinates.join(',')}</coordinates>
            </Point>
            </Placemark>`;
                            }
                        } else if (geometryType === "LineString") {
                            const lineCoordinates = coordinates.map(coord => coord.join(',')).join(' ');
                            return `<Placemark>
<name>${properties.name || ''}</name>
<description>${properties.description || ''}</description>
<Style>
<LineStyle>
<color>${lineColor}</color>
<width>2</width>
            </LineStyle>
            </Style>
<LineString>
<coordinates>${lineCoordinates}</coordinates>
            </LineString>
            </Placemark>`;
                        } else if (geometryType === "Polygon") {
                            const polygonCoordinates = coordinates.map(ring => ring.map(coord => coord.join(',')).join(' ')).join(' ');
                            return `<Placemark>
<name>${properties.name || ''}</name>
<description>${properties.description || ''}</description>
<Style>
<LineStyle>
<color>${lineColor}</color>
            </LineStyle>
<PolyStyle>
<color>${fillColor}</color>
            </PolyStyle>
            </Style>
<Polygon>
<outerBoundaryIs>
<LinearRing>
<coordinates>${polygonCoordinates}</coordinates>
            </LinearRing>
            </outerBoundaryIs>
            </Polygon>
            </Placemark>`;
                        }
                    }

                    function createStyles(features) {
                        const uniqueIcons = [...new Set(features.map(f => f.properties.iconUrl).filter(Boolean))];
                        return uniqueIcons.map(iconUrl => {
                            const localUrl = `files/${iconUrl.split('/').pop().replace(/\.\w+$/, '.png')}`;
                            return `
<Style id="${localUrl}">
<IconStyle>
<Icon>
<href>${localUrl}</href>
            </Icon>
<hotSpot x="0.5" y="0.5" xunits="fraction" yunits="fraction"/>
            </IconStyle>
<ListStyle>
<ItemIcon>
<href>${localUrl}</href>
            </ItemIcon>
            </ListStyle>
            </Style>
<StyleMap id="m_${localUrl}">
<Pair>
<key>normal</key>
<styleUrl>#${localUrl}</styleUrl>
            </Pair>
<Pair>
<key>highlight</key>
<styleUrl>#${localUrl}</styleUrl>
            </Pair>
            </StyleMap>`;
                        }).join('');
                    }

                    const placemarks = geojson.features.map(createPlacemark).join('');
                    const styles = createStyles(geojson.features);

                    return `${kmlHeader}${styles}${placemarks}${kmlFooter}`;
                }








                // Seleciona os elementos necessários
                var toolbar = document.querySelector('.map-toolbar');
                var drawToolbar = document.querySelectorAll('.leaflet-draw-toolbar');
                var printButton = document.querySelector('.leaflet-control-browser-print');
                var layersControl = document.querySelector('.leaflet-control-layers'); // Seleciona o controle de camadas
                var toggleControlsBtn = document.getElementById('toggleControlsBtn'); // Seleciona o botão de desativar controles
                var freehandButton; // Botão de desenho à mão livre
                var measureToggleButton; // Botão de medir distâncias e áreas
var translateButton = document.querySelector('.google-translate-control'); // Seleciona o botão de tradução

if (window.innerWidth <= 600) {
    toolbar.style.display = 'none';
    drawToolbar.forEach(function(toolbar) {
        toolbar.style.display = 'none';
    });
    if (printButton) printButton.style.display = 'none';
    if (layersControl) layersControl.style.display = 'none'; // Ocultar controle de camadas
    if (freehandButton) freehandButton.style.display = 'none'; // Ocultar botão de desenho à mão livre
    if (measureToggleButton) measureToggleButton.style.display = 'none'; // Ocultar botão de medição
    if (translateButton) translateButton.style.display = 'none'; // Ocultar botão de tradução
} else {
    toolbar.style.display = 'flex';
    drawToolbar.forEach(function(toolbar) {
        toolbar.style.display = 'block';
    });
    if (printButton) printButton.style.display = 'block';
    if (layersControl) layersControl.style.display = 'block'; // Mostrar controle de camadas
    if (freehandButton) freehandButton.style.display = 'block'; // Mostrar botão de desenho à mão livre
    if (measureToggleButton) measureToggleButton.style.display = 'block'; // Mostrar botão de medição
    if (translateButton) translateButton.style.display = 'block'; // Mostrar botão de tradução
    if (toggleControlsBtn) {
        toggleControlsBtn.style.display = 'block';
        toggleControlsBtn.textContent = 'Ocultar Controles';
    }
}

document.getElementById('toggleControlsBtn').addEventListener('click', function() {
    if (toolbar.style.display === 'none' || toolbar.style.display === '') {
        toolbar.style.display = 'flex';
        drawToolbar.forEach(function(toolbar) {
            toolbar.style.display = 'block'; // Mostrar controles de desenho
        });
        if (printButton) printButton.style.display = 'block'; // Mostrar botão de imprimir
        if (layersControl) layersControl.style.display = 'block'; // Mostrar controle de camadas
        if (freehandButton) freehandButton.style.display = 'block'; // Mostrar botão de desenho à mão livre
        if (measureToggleButton) measureToggleButton.style.display = 'block'; // Mostrar botão de medição
        if (translateButton) translateButton.style.display = 'block'; // Mostrar botão de tradução
        this.textContent = 'Ocultar Controles';
    } else {
        toolbar.style.display = 'none';
        drawToolbar.forEach(function(toolbar) {
            toolbar.style.display = 'none'; // Ocultar controles de desenho
        });
        if (printButton) printButton.style.display = 'none'; // Ocultar botão de imprimir
        if (layersControl) layersControl.style.display = 'none'; // Ocultar controle de camadas
        if (freehandButton) freehandButton.style.display = 'none'; // Ocultar botão de desenho à mão livre
        if (measureToggleButton) measureToggleButton.style.display = 'none'; // Ocultar botão de medição
        if (translateButton) translateButton.style.display = 'none'; // Ocultar botão de tradução
        this.textContent = 'Mostrar Controles';
    }
});





                var customLayers = {}; // Objeto para armazenar as camadas adicionadas dinamicamente

                function getSigsData() {
                    return fetch('/get_sigs.php') // Certifique-se de que este endpoint existe e retorna os dados necessários
                        .then(response => response.json());
                }

                function getWMSLayers(wmsURL) {
                    var capabilitiesURL = '/proxy.php?url=' + encodeURIComponent(wmsURL + '?service=WMS&request=GetCapabilities');

                    return fetch(capabilitiesURL)
                        .then(response => response.text())
                        .then(text => {
                        var parser = new DOMParser();
                        var xmlDoc = parser.parseFromString(text, 'application/xml');

                        var layers = [];
                        var layerNodes = xmlDoc.getElementsByTagName('Layer');

                        // Ignora o primeiro "Layer" que é o pai
                        for (var i = 1; i < layerNodes.length; i++) {
                            var layerNode = layerNodes[i];
                            var nameNode = layerNode.getElementsByTagName('Name')[0];
                            var titleNode = layerNode.getElementsByTagName('Title')[0];
                            if (nameNode) {
                                var layer = {
                                    Name: nameNode.textContent,
                                    Title: titleNode ? titleNode.textContent : nameNode.textContent
                                };
                                layers.push(layer);
                            }
                        }

                        // Ordena as camadas em ordem alfabética pelo Título
                        layers.sort(function(a, b) {
                            var titleA = a.Title.toLowerCase();
                            var titleB = b.Title.toLowerCase();
                            if (titleA < titleB) return -1;
                            if (titleA > titleB) return 1;
                            return 0;
                        });

                        return layers;
                    })
                        .catch(error => {
                        console.error('Erro ao obter camadas WMS:', error);
                        Swal.fire('Erro!', 'Não foi possível obter as camadas do servidor WMS.', 'error');
                    });
                }



                function addWMSLayerToMap(wmsURL, layerName, layerTitle) {
                    var layer = L.tileLayer.wms(wmsURL, {
                        layers: layerName,
                        format: 'image/png',
                        transparent: true,
                        version: '1.1.1'
                    });

                    // Adiciona a camada ao mapa e ao controle de camadas
                    addNewOverlayLayer(layerTitle, layer);

                    // Armazena a camada em customLayers para referência futura
                    customLayers[layerTitle] = layer;
                }












                // Variável global para armazenar as tarefas
                var taskSequence = [];
                let existingParameters = {};
                let selectedTask = '';

                // Função para desenhar a área de seleção
                async function drawSelectionArea() {
                    return new Promise((resolve) => {
                        // Inicia o desenho de um polígono sem adicionar ao drawnItems
                        const drawPolygon = new L.Draw.Polygon(map, {
                            showArea: true,
                            allowIntersection: false,
                            drawError: {
                                color: '#e1e100',
                                message: '<strong>Polígono inválido</strong>'
                            },
                            shapeOptions: {
                                color: '#97009c'
                            }
                        });
                        drawPolygon.enable();

                        // Configura um listener para capturar o desenho quando concluído
                        map.once('draw:created', function (e) {
                            if (e.layerType === 'polygon') {
                                const selectionArea = e.layer;

                                // Desabilitar o modo de desenho
                                drawPolygon.disable();

                                // Retornar a área desenhada
                                resolve(selectionArea);
                            } else {
                                drawPolygon.disable();
                                resolve(null);
                            }
                        });

                        // Listener para caso o usuário cancele o desenho
                        map.once('draw:canceled', function () {
                            drawPolygon.disable();
                            resolve(null);
                        });

                        // Listener para o botão "Cancelar" do controle de desenho
                        map.once('draw:drawstop', function () {
                            drawPolygon.disable();
                            resolve(null);
                        });
                    });
                }

                // Função para iniciar o processo de criação de tarefas
                async function startPlanning() {
                    // Pergunta ao usuário se deseja limpar a camada de planejamento
                    const { isConfirmed } = await Swal.fire({
                        title: 'Limpar Camada de Planejamento',
                        text: 'Deseja limpar a camada de planejamento antes de iniciar um novo planejamento?',
                        icon: 'question',
                        showCancelButton: true,
                        confirmButtonText: 'Sim',
                        cancelButtonText: 'Não'
                    });

                    if (isConfirmed) {
                        planejamentoLayer.clearLayers();
                        console.log('Camada de planejamento limpa.');
                    }

                    // Inicia a definição de tarefas em uma única tela
                    await defineTasksInSingleScreen();
                }

                async function getTaskParametersHtml(selectedTask, existingParameters = {}) {
                    switch (selectedTask) {
                        case 'findHighestPoint':
                            // Criar o select para selecionar a camada de origem dos ícones
                            const layerOptionsFind = {
                                'drawnItems': 'Camada de Desenho Atual',
                                'planningSuggestions': 'Sugestão de Planejamento'
                            };
                            const layerSelectHtmlFind = `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconLayerSelect" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Selecione a Camada de Origem dos Ícones:
            </label>
<select id="iconLayerSelect" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
${Object.entries(layerOptionsFind).map(([value, text]) => `
<option value="${value}" ${existingParameters.iconLayer === value ? 'selected' : ''}>
${text}
            </option>
`).join('')}
            </select>
            </div>
`;

                            // Obter a lista de ícones disponíveis para seleção
                            let iconListFind = await fetch('symbols/icons.php')
                            .then(response => response.json())
                            .catch(error => {
                                console.error('Erro ao obter a lista de ícones:', error);
                                Swal.fire('Erro', 'Não foi possível obter a lista de ícones.', 'error');
                                return [];
                            });

                            if (!iconListFind || iconListFind.length === 0) {
                                return '<p style="text-align: center;"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Nenhum ícone disponível.</p>';
                            }

                            // Criar as opções do select com os ícones disponíveis
                            let iconOptionsHtmlFind = '';
                            iconListFind.forEach(icon => {
                                const iconNameWithExtension = icon.substring(icon.lastIndexOf('/') + 1);
                                const iconName = iconNameWithExtension.split('.')[0];
                                iconOptionsHtmlFind += `
<option value="${icon}" ${existingParameters.iconType === icon ? 'selected' : ''}>
${icon.split('/')[2]}/${iconName}
            </option>
`;
                            });

                            // Para selecionar o ícone a ser inserido
                            let iconInsertOptionsHtmlFind = '';
                            iconListFind.forEach(icon => {
                                const iconNameWithExtension = icon.substring(icon.lastIndexOf('/') + 1);
                                const iconName = iconNameWithExtension.split('.')[0];
                                iconInsertOptionsHtmlFind += `
<option value="${icon}" ${existingParameters.iconToInsert === icon ? 'selected' : ''}>
${icon.split('/')[2]}/${iconName}
            </option>
`;
                            });

                            // Adicionar novos campos para quantidade de ícones e distância máxima entre eles
                            const newIconFieldsHtmlFind = `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="numberOfNewIcons" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-plus-square" style="margin-right: 8px;"></i> Quantos Novos Ícones Deseja Colocar:
            </label>
<input id="numberOfNewIcons" class="swal2-input" type="number" min="1" value="${existingParameters.numberOfNewIcons || 1}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 20px;">
<label for="maxDistanceBetweenNewIcons" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-ruler-combined" style="margin-right: 8px;"></i> Distância Máxima entre Novos Ícones (km):
            </label>
<input id="maxDistanceBetweenNewIcons" class="swal2-input" type="number" min="0" step="0.1" value="${existingParameters.maxDistanceBetweenNewIcons || 1}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
`;

                            return `
${layerSelectHtmlFind}
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconType" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-icons" style="margin-right: 8px;"></i> Selecione o Tipo de Ícone Existente:
            </label>
<select id="iconType" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconTypeImage').src = this.value">
${iconOptionsHtmlFind}
            </select>
<img id="iconTypeImage" src="${existingParameters.iconType || iconListFind[0]}" alt="Ícone Selecionado" style="width: 24px; height: 24px; margin-left: 10px;">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="maxDistance" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-ruler-horizontal" style="margin-right: 8px;"></i> Distância Máxima (km):
            </label>
<input id="maxDistance" class="swal2-input" type="number" value="${existingParameters.maxDistance || 10}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconToInsert" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-plus-circle" style="margin-right: 8px;"></i> Selecione o Ícone para Inserir:
            </label>
<select id="iconToInsert" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconToInsertImage').src = this.value">
${iconInsertOptionsHtmlFind}
            </select>
<img id="iconToInsertImage" src="${existingParameters.iconToInsert || iconListFind[0]}" alt="Ícone a Inserir" style="width: 24px; height: 24px; margin-left: 10px;">
            </div>
${newIconFieldsHtmlFind}
<div style="display: flex; justify-content: center; margin-top: 10px;">
            </div>
`;


                        case 'placeIcons':
                            // Obter a lista de ícones disponíveis para seleção
                            let iconListPlace = await fetch('symbols/icons.php')
                            .then(response => response.json())
                            .catch(error => {
                                console.error('Erro ao obter a lista de ícones:', error);
                                Swal.fire('Erro', 'Não foi possível obter a lista de ícones.', 'error');
                                return [];
                            });

                            if (!iconListPlace || iconListPlace.length === 0) {
                                return '<p style="text-align: center;"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Nenhum ícone disponível.</p>';
                            }

                            // Criar as opções do select com os ícones disponíveis
                            let iconOptionsHtmlPlace = '';
                            iconListPlace.forEach(icon => {
                                const iconNameWithExtension = icon.substring(icon.lastIndexOf('/') + 1);
                                const iconName = iconNameWithExtension.split('.')[0];
                                iconOptionsHtmlPlace += `
<option value="${icon}" ${existingParameters.iconUrl === icon ? 'selected' : ''}>
${icon.split('/')[2]}/${iconName}
            </option>
`;

                            });

                            // Adicionar novos campos para quantidade máxima de ícones e distância mínima entre eles
                            const newIconFieldsHtmlPlace = `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="maxNumberOfIcons" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-hashtag" style="margin-right: 8px;"></i> Quantidade Máxima de Ícones a Inserir:
            </label>
<input id="maxNumberOfIcons" class="swal2-input" type="number" min="1" value="${existingParameters.maxNumberOfIcons || 10}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 20px;">
<label for="minDistanceBetweenIcons" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-ruler-combined" style="margin-right: 8px;"></i> Distância Mínima entre Ícones (m):
            </label>
<input id="minDistanceBetweenIcons" class="swal2-input" type="number" min="0" step="1" value="${existingParameters.minDistanceBetweenIcons || 100}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
`;

                            return `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconToInsert" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-plus-circle" style="margin-right: 8px;"></i> Selecione o Ícone para Inserir:
            </label>
<select id="iconToInsert" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconToInsertImage').src = this.value">
${iconOptionsHtmlPlace}
            </select>
<img id="iconToInsertImage" src="${existingParameters.iconUrl || iconListPlace[0]}" alt="Ícone a Inserir" style="width: 24px; height: 24px; margin-left: 10px;" onerror="this.src='symbols/default.svg'">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="criteria" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-balance-scale" style="margin-right: 8px;"></i> Critério (elevação mínima):
            </label>
<input id="criteria" class="swal2-input" type="number" value="${existingParameters.criteria || 100}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
${newIconFieldsHtmlPlace}
<div style="display: flex; justify-content: center; margin-top: 10px;">
<!-- Possíveis botões ou elementos adicionais -->
            </div>
`;


                        case 'drawLinesBetweenIcons':
                            // Obter as camadas disponíveis para selecionar
                            const layerOptionsLines = {
                                'drawnItems': 'Camada de Desenho Atual',
                                'planningSuggestions': 'Sugestão de Planejamento'
                            };
                            const layerSelectHtmlLines = `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconLayerSelect" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Selecione a Camada de Origem dos Ícones:
            </label>
<select id="iconLayerSelect" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
${Object.entries(layerOptionsLines).map(([value, text]) => `
<option value="${value}" ${existingParameters.iconLayer === value ? 'selected' : ''}>
${text}
            </option>
`).join('')}
            </select>
            </div>
`;

                            // Obter a lista de ícones disponíveis para seleção
                            let iconListLines = await fetch('symbols/icons.php')
                            .then(response => response.json())
                            .catch(error => {
                                console.error('Erro ao obter a lista de ícones:', error);
                                Swal.fire('Erro', 'Não foi possível obter a lista de ícones.', 'error');
                                return [];
                            });

                            if (!iconListLines || iconListLines.length === 0) {
                                return '<p style="text-align: center;"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Nenhum ícone disponível.</p>';
                            }

                            // Criar as opções do select com os ícones disponíveis (valor completo)
                            let iconOptionsHtmlLines = '';

                            iconListLines.forEach(icon => {
                                const iconNameWithExtension = icon.substring(icon.lastIndexOf('/') + 1);
                                const iconName = iconNameWithExtension.split('.')[0];
                                iconOptionsHtmlLines += `
<option value="${icon}" ${existingParameters.iconType === icon ? 'selected' : ''}>
${icon.split('/')[2]}/${iconName}
            </option>
`;
                            });

                            // Adicionar novos campos para quantidade máxima de ligações e distância mínima entre linhas
                            const newLineFieldsHtml = `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="maxConnectionsPerIcon" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-network-wired" style="margin-right: 8px;"></i> Quantidade Máxima de Ligações por Ícone:
            </label>
<input id="maxConnectionsPerIcon" class="swal2-input" type="number" min="1" value="${existingParameters.maxConnectionsPerIcon || 3}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 20px;">
<label for="minDistanceBetweenLines" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-ruler-combined" style="margin-right: 8px;"></i> Distância Mínima entre Ligações (m):
            </label>
<input id="minDistanceBetweenLines" class="swal2-input" type="number" min="0" step="1" value="${existingParameters.minDistanceBetweenLines || 50}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
`;

                            return `
${layerSelectHtmlLines}
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconType" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-link" style="margin-right: 8px;"></i> Selecione o Tipo de Ícones para Conectar:
            </label>
<select id="iconType" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconTypeImage').src = this.value">
${iconOptionsHtmlLines}
            </select>
<img id="iconTypeImage" src="${existingParameters.iconType || iconListLines[0]}" alt="Ícone Selecionado" style="width: 24px; height: 24px; margin-left: 10px;" onerror="this.src='symbols/default.svg'">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="maxDistance" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-ruler-horizontal" style="margin-right: 8px;"></i> Distância Máxima entre Ícones (km):
            </label>
<input id="maxDistance" class="swal2-input" type="number" value="${existingParameters.maxDistance || 10}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
${newLineFieldsHtml}
<div style="display: flex; justify-content: center; margin-top: 10px;">
<!-- Possíveis botões ou elementos adicionais -->
            </div>
`;


                        case 'connectDifferentIcons':
                            // Obter as camadas disponíveis para selecionar
                            const layerOptionsConnect = {
                                'drawnItems': 'Camada de Desenho Atual',
                                'planningSuggestions': 'Sugestão de Planejamento'
                            };
                            const layerSelectHtmlConnect = `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconLayerSelect" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Selecione a Camada de Origem dos Ícones:
            </label>
<select id="iconLayerSelect" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
${Object.entries(layerOptionsConnect).map(([value, text]) => `
<option value="${value}" ${existingParameters.iconLayer === value ? 'selected' : ''}>
${text}
            </option>
`).join('')}
            </select>
            </div>
`;

                            // Obter a lista de ícones disponíveis para seleção
                            let iconListConnect = await fetch('symbols/icons.php')
                            .then(response => response.json())
                            .catch(error => {
                                console.error('Erro ao obter a lista de ícones:', error);
                                Swal.fire('Erro', 'Não foi possível obter a lista de ícones.', 'error');
                                return [];
                            });

                            if (!iconListConnect || iconListConnect.length === 0) {
                                return '<p style="text-align: center;"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Nenhum ícone disponível.</p>';
                            }

                            // Criar as opções do select com os ícones disponíveis
                            let iconOptionsHtmlConnect1 = '';
                            let iconOptionsHtmlConnect2 = '';
                            iconListConnect.forEach(icon => {
                                const iconNameWithExtension = icon.substring(icon.lastIndexOf('/') + 1);
                                const iconName = iconNameWithExtension.split('.')[0];
                                iconOptionsHtmlConnect1 += `
<option value="${icon}" ${existingParameters.iconType1 === icon ? 'selected' : ''}>
${icon.split('/')[2]}/${iconName}
            </option>
`;
                                iconOptionsHtmlConnect2 += `
<option value="${icon}" ${existingParameters.iconType2 === icon ? 'selected' : ''}>
${icon.split('/')[2]}/${iconName}
            </option>
`;
                            });

                            // Adicionar novos campos para quantidade máxima de ligações e distância mínima entre linhas
                            const newLineFieldsHtmlConnect = `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="maxConnectionsSource" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-network-wired" style="margin-right: 8px;"></i> Máximo de conexões por Ícone Fonte (${existingParameters.iconType1 || ''}):
            </label>
<input id="maxConnectionsSource" class="swal2-input" type="number" value="${existingParameters.maxConnectionsSource || 2}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="maxConnectionsTarget" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-network-wired" style="margin-right: 8px;"></i> Máximo de conexões por Ícone Alvo (${existingParameters.iconType2 || ''}):
            </label>
<input id="maxConnectionsTarget" class="swal2-input" type="number" value="${existingParameters.maxConnectionsTarget || 8}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 20px;">
<label for="connectionCriterion" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-balance-scale" style="margin-right: 8px;"></i> Critério de Conexão:
            </label>
<select id="connectionCriterion" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
<option value="closest" ${existingParameters.connectionCriterion === 'closest' ? 'selected' : ''}>
Ícones mais próximos
            </option>
<option value="farthest" ${existingParameters.connectionCriterion === 'farthest' ? 'selected' : ''}>
Ícones mais distantes
            </option>
            </select>
            </div>
`;

                            return `
${layerSelectHtmlConnect}

<!-- Select para o Primeiro Tipo de Ícone com Imagem -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconType1" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Selecione o Primeiro Tipo de Ícone:
            </label>
<select id="iconType1" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconType1Image').src = this.value">
${iconOptionsHtmlConnect1}
            </select>
<img id="iconType1Image" src="${existingParameters.iconType1 || iconListConnect[0]}" alt="Ícone Selecionado 1" style="width: 24px; height: 24px; margin-left: 10px;" onerror="this.src='symbols/default.svg'">
            </div>

<!-- Select para o Segundo Tipo de Ícone com Imagem -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconType2" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Selecione o Segundo Tipo de Ícone:
            </label>
<select id="iconType2" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconType2Image').src = this.value">
${iconOptionsHtmlConnect2}
            </select>
<img id="iconType2Image" src="${existingParameters.iconType2 || iconListConnect[0]}" alt="Ícone Selecionado 2" style="width: 24px; height: 24px; margin-left: 10px;" onerror="this.src='symbols/default.svg'">
            </div>

<!-- Input para Distância Máxima entre Ícones -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="maxDistance" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-ruler-horizontal" style="margin-right: 8px;"></i> Distância Máxima entre Ícones (km):
            </label>
<input id="maxDistance" class="swal2-input" type="number" value="${existingParameters.maxDistance || 10}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>

<!-- Inputs para Máximo de Conexões e Critério de Conexão -->
${newLineFieldsHtmlConnect}

`;

                            return `
${layerSelectHtmlConnect}

<!-- Select para o Primeiro Tipo de Ícone com Imagem -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconType1" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Selecione o Primeiro Tipo de Ícone:
            </label>
<select id="iconType1" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconType1Image').src = this.value">
${iconOptionsHtmlConnect1}
            </select>
<img id="iconType1Image" src="${existingParameters.iconType1 || iconListConnect[0]}" alt="Ícone Selecionado 1" style="width: 24px; height: 24px; margin-left: 10px;" onerror="this.src='symbols/default.svg'">
            </div>

<!-- Select para o Segundo Tipo de Ícone com Imagem -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconType2" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Selecione o Segundo Tipo de Ícone:
            </label>
<select id="iconType2" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconType2Image').src = this.value">
${iconOptionsHtmlConnect2}
            </select>
<img id="iconType2Image" src="${existingParameters.iconType2 || iconListConnect[0]}" alt="Ícone Selecionado 2" style="width: 24px; height: 24px; margin-left: 10px;" onerror="this.src='symbols/default.svg'">
            </div>

<!-- Input para Distância Máxima entre Ícones -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="maxDistance" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-ruler-horizontal" style="margin-right: 8px;"></i> Distância Máxima entre Ícones (km):
            </label>
<input id="maxDistance" class="swal2-input" type="number" value="${existingParameters.maxDistance || 10}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>

<!-- Inputs para Máximo de Conexões e Critério de Conexão -->
${newLineFieldsHtmlConnect}

<!-- Select para Critério de Conexão (Sem Imagem) -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 20px;">
<label for="connectionCriterion" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-balance-scale" style="margin-right: 8px;"></i> Critério de Conexão:
            </label>
<select id="connectionCriterion" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
<option value="closest" ${existingParameters.connectionCriterion === 'closest' ? 'selected' : ''}>
Ícones mais próximos
            </option>
<option value="farthest" ${existingParameters.connectionCriterion === 'farthest' ? 'selected' : ''}>
Ícones mais distantes
            </option>
            </select>
            </div>

<div style="display: flex; justify-content: center; margin-top: 10px;">
<!-- Possíveis botões ou elementos adicionais -->
            </div>
`;

                        case 'drawCoverageArea':
                            // Dentro do case 'drawCoverageArea':
                            const layerOptionsCoverage = {
                                'drawnItems': 'Camada de Desenho Atual',
                                'planningSuggestions': 'Sugestão de Planejamento'
                            };

                            // Dentro do case 'drawCoverageArea':

                            const layerSelectHtmlCoverage = `
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="coverageLayerSelect" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Selecione a Camada de Origem dos Desenhos:
            </label>
<select id="coverageLayerSelect" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
${Object.entries(layerOptionsCoverage).map(([value, text]) => `
<option value="${value}" ${existingParameters.coverageLayer === value ? 'selected' : ''}>
${text}
            </option>
`).join('')}
            </select>
            </div>
`;

                            // Obter a lista de ícones disponíveis
                            let iconListCoverage = await fetch('symbols/icons.php')
                            .then(response => response.json())
                            .catch(error => {
                                console.error('Erro ao obter a lista de ícones:', error);
                                Swal.fire('Erro', 'Não foi possível obter a lista de ícones.', 'error');
                                return [];
                            });

                            if (!iconListCoverage || iconListCoverage.length === 0) {
                                return '<p style="text-align: center;"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Nenhum ícone disponível.</p>';
                            }

                            // Criar as opções do select com os ícones disponíveis
                            let iconOptionsHtmlCoverage = '';                            
                            iconListCoverage.forEach(icon => {
                                const iconNameWithExtension = icon.substring(icon.lastIndexOf('/') + 1);
                                const iconName = iconNameWithExtension.split('.')[0];
                                iconOptionsHtmlCoverage += `
<option value="${icon}" ${existingParameters.iconUrl === icon ? 'selected' : ''}>
${icon.split('/')[2]}/${iconName}
            </option>
`;
                            });

                            // Criar as opções para os tipos de ícones a cobrir
                            let iconTypesToCoverOptions = '';
                            iconListCoverage.forEach(icon => {
                                const iconNameWithExtension = icon.substring(icon.lastIndexOf('/') + 1);
                                const iconName = iconNameWithExtension.split('.')[0];
                                try{
                                    iconTypesToCoverOptions += `
<option value="${icon}" ${existingParameters.iconTypesToCover.includes(icon) ? 'selected' : ''}>
${icon.split('/')[2]}/${iconName}
            </option>

`;
                                } catch (e) {
                                    iconTypesToCoverOptions += `
<option value="${icon}">
${icon.split('/')[2]}/${iconName}
            </option>

`;
                                }
                            });

                            return `
${layerSelectHtmlCoverage}

<!-- Select para o Ícone Central com Imagem -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconToInsert" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-map-marker-alt" style="margin-right: 8px;"></i> Selecione o Ícone Central:
            </label>
<select id="iconToInsert" class="swal2-input" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;"
onchange="document.getElementById('iconToInsertImage').src = this.value">
${iconOptionsHtmlCoverage}
            </select>
<img id="iconToInsertImage" src="${existingParameters.iconUrl || iconListCoverage[0]}" alt="Ícone a Inserir" style="width: 24px; height: 24px; margin-left: 10px;" onerror="this.src='symbols/default.svg'">
            </div>

<!-- Input para Raio da Cobertura -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="radius" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-compass" style="margin-right: 8px;"></i> Raio da Cobertura (km):
            </label>
<input id="radius" class="swal2-input" type="number" value="${existingParameters.radius || 10}" style="flex: 1; margin-left: 10px; padding: 5px; border-radius: 4px;">
            </div>

<!-- Select Múltiplo para Tipos de Ícones a Cobrir -->
<div class="form-group" style="display: flex; align-items: center; margin-bottom: 15px;">
<label for="iconTypesToCover" style="flex: 0 0 40%; display: flex; align-items: center; font-weight: bold; font-size: 14px;">
<i class="fas fa-layer-group" style="margin-right: 8px;"></i> Tipos de Ícones a Cobrir (Seleção Múltipla):
            </label>
<select 
id="iconTypesToCover" 
class="swal2-input" 
multiple 
size="10" 
style="
flex: 1; 
margin-left: 10px; 
padding: 5px; 
border-radius: 4px; 
height: auto; /* Permite que a altura seja ajustada automaticamente */
max-height: 300px; /* Define uma altura máxima para evitar que a caixa fique muito grande */
overflow-y: auto; /* Adiciona rolagem vertical se houver muitas opções */
">
${iconTypesToCoverOptions}
            </select>
            </div>
<!-- Container para Botões ou Elementos Adicionais -->
<div style="display: flex; justify-content: center; margin-top: 10px;">
<!-- Possíveis botões ou elementos adicionais -->
            </div>
`;


                        default:
                            return '<p style="text-align: center;"><i class="fas fa-question-circle" style="color: #6c757d;"></i> Tarefa desconhecida.</p>';
                                        }
                }





                // Função para definir tarefas na tela
                async function defineTasksInSingleScreen() {
                    // Obter os tipos de tarefas disponíveis
                    const taskOptions = {
                        'findHighestPoint': 'Encontrar o ponto mais alto próximo a um ícone',
                        'placeIcons': 'Colocar múltiplos ícones em locais que atendam a certos critérios',
                        'drawLinesBetweenIcons': 'Desenhar linhas entre ícones do mesmo tipo',
                        'connectDifferentIcons': 'Conectar ícones diferentes com linhas',
                        'drawCoverageArea': 'Desenhar área de cobertura com ícone central'
                    };

                    // Variáveis para rastrear o modo de edição
                    let isEditing = false;
                    let editingIndex = null;

                    // HTML para o modal
                    let modalContent = `
<div style="text-align: left; max-height: 80vh; overflow-y: auto; padding: 20px;">

<label for="taskSelect">Selecione uma Tarefa:</label>
<select id="taskSelect" class="swal2-input">
<option value="" disabled ${selectedTask ? '' : 'selected'}>Selecione uma tarefa</option>
${Object.entries(taskOptions).map(([value, text]) => `<option value="${value}" ${selectedTask === value ? 'selected' : ''}>${text}</option>`).join('')}
            </select>
<div id="taskParameters" style="margin-top: 10px;"></div>
<button id="addTaskButton" class="swal2-confirm swal2-styled" style="margin-top: 10px;"><i class="fa fa-plus"></i> Adicionar Tarefa</button>
<button id="clearTasksButton" class="swal2-cancel swal2-styled" style="margin-top: 10px; margin-left: 10px;"><i class="fa fa-trash"></i> Limpar Tarefa(s)</button>
<hr>
<h3>Sequência de Tarefas:</h3>
<div id="taskSequenceList"></div>
<hr>
<div style="display: flex; justify-content: space-between; margin-top: 10px;">
<button id="saveSequenceButton" class="swal2-confirm swal2-styled" style="flex: 1; margin-right: 10px;"><i class="fa fa-save"></i> Salvar Sequência</button>
<button id="loadSequenceButton" class="swal2-confirm swal2-styled" style="flex: 1; margin-right: 10px;"><i class="fa fa-folder-open"></i> Carregar Sequência</button>
<button id="executeSequenceButton" class="swal2-confirm swal2-styled" style="flex: 1;"><i class="fa fa-play"></i> Executar Sequência</button>
<button id="deleteSequenceButton" class="swal2-confirm swal2-styled" style="flex: 1; margin-left: 10px;"><i class="fa fa-trash"></i> Deletar Sequência</button>

            </div>

            </div>
`;

                    // Mostrar o modal
                    await Swal.fire({
                        title: '<i class="fa fa-tasks"></i> Planejamento de Tarefas',
                        html: modalContent,
                        width: '80%', // Define a largura do modal para 80% da viewport
                        showConfirmButton: false,
                        showCancelButton: true,
                        cancelButtonText: '<i class="fa fa-times"></i> Cancelar',
                        allowOutsideClick: false,
                        didOpen: async () => {
                            const popup = Swal.getPopup();
                            const taskSelect = popup.querySelector('#taskSelect');
                            const taskParametersDiv = popup.querySelector('#taskParameters');
                            const addTaskButton = popup.querySelector('#addTaskButton');
                            const taskSequenceList = popup.querySelector('#taskSequenceList');
                            const saveSequenceButton = popup.querySelector('#saveSequenceButton');
                            const loadSequenceButton = popup.querySelector('#loadSequenceButton'); // Novo botão
                            const executeSequenceButton = popup.querySelector('#executeSequenceButton');
                            const deleteSequenceButton = popup.querySelector('#deleteSequenceButton');
                            const clearTasksButton = popup.querySelector('#clearTasksButton');


                            // Atualiza os parâmetros da tarefa se uma tarefa já estiver selecionada
                            if (selectedTask) {
                                taskParametersDiv.innerHTML = await getTaskParametersHtml(selectedTask, existingParameters);
                            }

                            // Função para atualizar a lista de tarefas
                            function updateTaskSequenceList() {
                                if (taskSequence.length === 0) {
                                    taskSequenceList.innerHTML = '<p>Nenhuma tarefa adicionada.</p>';
                                } else {
                                    taskSequenceList.innerHTML = taskSequence.map((task, index) => {
                                        if (!task || !task.task || !task.parameters) {
                                            console.error(`Tarefa no índice ${index} está incompleta:`, task);
                                            return '';
                                        }
                                        return `<div style="margin-bottom: 10px;">
<b>${index + 1}. ${taskOptions[task.task]}</b>
<button data-index="${index}" class="viewTaskButton" style="margin-left: 5px; cursor: pointer;"><i class="fa fa-info-circle"></i></button>
<button data-index="${index}" class="editTaskButton" style="margin-left: 5px; cursor: pointer;"><i class="fa fa-edit"></i></button>
<button data-index="${index}" class="removeTaskButton" style="margin-left: 5px; cursor: pointer;"><i class="fa fa-trash"></i></button>
            </div>`;
                                    }).join('');
                                    // Adicionar eventos para os botões de visualizar, editar e remover
                                    taskSequenceList.querySelectorAll('.viewTaskButton').forEach(button => {
                                        button.addEventListener('click', (e) => {
                                            const index = e.target.closest('button').getAttribute('data-index');
                                            viewTask(index);
                                        });
                                    });
                                    taskSequenceList.querySelectorAll('.editTaskButton').forEach(button => {
                                        button.addEventListener('click', async (e) => {
                                            const index = e.target.closest('button').getAttribute('data-index');
                                            await editTask(index);
                                        });
                                    });
                                    taskSequenceList.querySelectorAll('.removeTaskButton').forEach(button => {
                                        button.addEventListener('click', (e) => {
                                            const index = e.target.closest('button').getAttribute('data-index');
                                            removeTask(index);
                                        });
                                    });
                                }
                            }

                            // Chama a atualização inicial da lista
                            updateTaskSequenceList();

                            // Evento ao mudar a seleção de tarefa
                            taskSelect.addEventListener('change', async () => {
                                selectedTask = taskSelect.value;
                                existingParameters = {}; // Reset existing parameters
                                // Mostrar parâmetros para a tarefa selecionada
                                taskParametersDiv.innerHTML = await getTaskParametersHtml(selectedTask, existingParameters);
                            });

                            // Evento ao clicar em "Adicionar/Atualizar Tarefa"
                            addTaskButton.addEventListener('click', async () => {
                                if (!selectedTask) {
                                    await Swal.fire('Aviso', 'Selecione uma tarefa antes de adicionar.', 'warning');
                                    return;
                                }
                                // Coletar parâmetros da tarefa
                                const taskParameters = await getTaskParametersValues(selectedTask, existingParameters);
                                if (taskParameters) {
                                    if (isEditing && editingIndex !== null) {
                                        // Atualizar a tarefa existente
                                        taskSequence[editingIndex] = {
                                            task: selectedTask,
                                            parameters: taskParameters
                                        };
                                        isEditing = false;
                                        editingIndex = null;
                                        addTaskButton.innerHTML = '<i class="fa fa-plus"></i> Adicionar Tarefa';
                                    } else {
                                        // Adicionar nova tarefa à sequência
                                        taskSequence.push({
                                            task: selectedTask,
                                            parameters: taskParameters
                                        });
                                    }
                                    // Limpar seleção
                                    taskSelect.value = '';
                                    taskParametersDiv.innerHTML = '';
                                    existingParameters = {};
                                    selectedTask = '';
                                    // Atualizar a lista de tarefas
                                    updateTaskSequenceList();
                                    // Manter o modal aberto
                                }
                            });

                            // Evento ao clicar em "Salvar Sequência"
                            saveSequenceButton.addEventListener('click', async () => {
                                if (taskSequence.length === 0) {
                                    Swal.fire('Aviso', 'Adicione pelo menos uma tarefa antes de salvar.', 'warning');
                                    return;
                                }
                                await saveTaskSequence();
                            });

                            // Evento ao clicar em "Carregar Sequência"
                            loadSequenceButton.addEventListener('click', async () => {
                                await loadTaskSequences();
                                // Atualizar a lista de tarefas após carregar
                                updateTaskSequenceList();
                                // Exibir o modal novamente para manter o fluxo
                                defineTasksInSingleScreen();
                            });


                            deleteSequenceButton.addEventListener('click', async () => {
                                await deleteTaskSequence();
                                // Exibir o modal novamente para manter o fluxo
                                defineTasksInSingleScreen();
                            });

                            // Evento ao clicar em "Executar Sequência"
                            executeSequenceButton.addEventListener('click', async () => {
                                if (taskSequence.length === 0) {
                                    Swal.fire('Aviso', 'Adicione pelo menos uma tarefa antes de executar.', 'warning');
                                    return;
                                }
                                await executeTaskSequence();
                                Swal.close(); // Fecha o modal após executar
                            });

                            // Função para visualizar detalhes da tarefa
                            function viewTask(index) {
                                const task = taskSequence[index];
                                if (!task) {
                                    Swal.fire('Erro', 'Tarefa não encontrada.', 'error');
                                    return;
                                }
                                const taskName = taskOptions[task.task];
                                const taskParams = task.parameters;

                                if (!taskName || !taskParams) {
                                    Swal.fire('Erro', 'Detalhes da tarefa estão incompletos.', 'error');
                                    return;
                                }

                                let paramsHtml = '<ul>';
                                for (const [key, value] of Object.entries(taskParams)) {
                                    paramsHtml += `<li><strong>${key}:</strong> ${value}</li>`;
                                }
                                paramsHtml += '</ul>';

                                Swal.fire({
                                    title: `<i class="fa fa-info-circle"></i> Detalhes da Tarefa`,
                                    html: `<b>${index + 1}. ${taskName}</b><br>${paramsHtml}`,
                                    icon: 'info',
                                    confirmButtonText: '<i class="fa fa-check"></i> Fechar',
                                    allowOutsideClick: false
                                }).then(() => {
                                    // Reabrir o modal principal após fechar os detalhes
                                    defineTasksInSingleScreen();
                                });
                            }

                            // Função para editar uma tarefa na sequência
                            async function editTask(index) {
                                const task = taskSequence[index];
                                if (!task) {
                                    Swal.fire('Erro', 'Tarefa não encontrada.', 'error');
                                    return;
                                }
                                existingParameters = task.parameters;
                                selectedTask = task.task;
                                isEditing = true;
                                editingIndex = index;
                                // Mostrar os parâmetros da tarefa para edição
                                taskParametersDiv.innerHTML = await getTaskParametersHtml(selectedTask, existingParameters);
                                // Atualizar o botão para "Atualizar Tarefa"
                                addTaskButton.innerHTML = '<i class="fa fa-sync-alt"></i> Atualizar Tarefa';
                                // Atualizar a seleção no select
                                taskSelect.value = selectedTask;
                            }

                            // Função para remover uma tarefa da sequência
                            function removeTask(index) {
                                Swal.fire({
                                    title: 'Confirmar Remoção',
                                    text: 'Tem certeza de que deseja remover esta tarefa?',
                                    icon: 'warning',
                                    showCancelButton: true,
                                    confirmButtonText: '<i class="fa fa-trash"></i> Remover',
                                    cancelButtonText: '<i class="fa fa-times"></i> Cancelar'
                                }).then((result) => {
                                    if (result.isConfirmed) {
                                        taskSequence.splice(index, 1);
                                        updateTaskSequenceList();
                                        Swal.fire('Removido!', 'A tarefa foi removida.', 'success').then(() => {
                                            // Reabrir o modal principal após remover
                                            defineTasksInSingleScreen();
                                        });
                                    }
                                });
                            }

                            // Evento ao clicar em "Limpar tarefa(s)"
                            clearTasksButton.addEventListener('click', async () => {
                                // Confirmar a ação com o usuário
                                const result = await Swal.fire({
                                    title: 'Confirmar Limpeza',
                                    text: 'Tem certeza de que deseja remover todas as tarefas atuais?',
                                    icon: 'warning',
                                    showCancelButton: true,
                                    confirmButtonText: '<i class="fa fa-trash"></i> Limpar',
                                    cancelButtonText: '<i class="fa fa-times"></i> Cancelar'
                                });

                                if (result.isConfirmed) {
                                    // Limpar a sequência de tarefas
                                    taskSequence = [];
                                    // Atualizar a lista de tarefas na interface
                                    updateTaskSequenceList();
                                    // Resetar as seleções e parâmetros
                                    taskSelect.value = '';
                                    taskParametersDiv.innerHTML = '';
                                    existingParameters = {};
                                    selectedTask = '';
                                    isEditing = false;
                                    editingIndex = null;
                                    addTaskButton.innerHTML = '<i class="fa fa-plus"></i> Adicionar Tarefa';
                                    // Log da ação
                                    addToLog('Todas as tarefas foram removidas.');
                                    defineTasksInSingleScreen();
                                }
                            });
                        }
                    });
                }
























                // Variável global para armazenar o log
                let logMessages = [];

                // Função auxiliar para serializar qualquer tipo de dado
                function serializeMessage(msg) {
                    if (typeof msg === 'string') {
                        return msg;
                    } else if (typeof msg === 'object') {
                        try {
                            return JSON.stringify(msg);
                        } catch (e) {
                            return String(msg);
                        }
                    } else if (typeof msg === 'function') {
                        return msg.toString();
                    } else if (typeof msg === 'undefined') {
                        return 'undefined';
                    } else {
                        return String(msg);
                    }
                }

                // Função addToLog atualizada para aceitar qualquer tipo de dado
                function addToLog(...messages) {
                    const timestamp = new Date().toLocaleTimeString();
                    const formattedMessage = messages.map(msg => serializeMessage(msg)).join(' ') + '\n';
                    logMessages += `[${timestamp}] ${formattedMessage}\n`;
                }






                // Função para obter os valores dos parâmetros da tarefa selecionada
                async function getTaskParametersValues(selectedTask, existingParameters) {
                    const popup = Swal.getPopup();
                    switch (selectedTask) {
                        case 'findHighestPoint': {
                            const iconLayer = popup.querySelector('#iconLayerSelect').value;
                            const iconType = popup.querySelector('#iconType').value;
                            const maxDistance = parseFloat(popup.querySelector('#maxDistance').value);
                            const iconToInsert = popup.querySelector('#iconToInsert').value;
                            const numberOfNewIcons = parseInt(popup.querySelector('#numberOfNewIcons').value, 10);
                            const maxDistanceBetweenNewIcons = parseFloat(popup.querySelector('#maxDistanceBetweenNewIcons').value);

                            if (!iconLayer || !iconType || isNaN(maxDistance) || !iconToInsert || isNaN(numberOfNewIcons) || isNaN(maxDistanceBetweenNewIcons)) {
                                Swal.fire('Aviso', 'Preencha todos os campos corretamente.', 'warning');
                                return null;
                            }

                            return {
                                iconLayer,
                                iconType,
                                maxDistance,
                                iconToInsert,
                                numberOfNewIcons, // Novo parâmetro
                                maxDistanceBetweenNewIcons, // Novo parâmetro
                                area: existingParameters.area || null
                            };
                        }

                        case 'placeIcons': {
                            const iconUrl = popup.querySelector('#iconToInsert').value;
                            const criteria = parseFloat(popup.querySelector('#criteria').value);
                            const maxNumberOfIcons = parseInt(popup.querySelector('#maxNumberOfIcons').value, 10);
                            const minDistanceBetweenIcons = parseFloat(popup.querySelector('#minDistanceBetweenIcons').value);

                            if (!iconUrl || isNaN(criteria) || isNaN(maxNumberOfIcons) || isNaN(minDistanceBetweenIcons)) {
                                Swal.fire('Aviso', 'Preencha todos os campos corretamente.', 'warning');
                                return null;
                            }

                            return {
                                iconUrl,
                                criteria,
                                maxNumberOfIcons,           // Novo parâmetro
                                minDistanceBetweenIcons,    // Novo parâmetro
                                area: existingParameters.area || null
                            };
                        }

                        case 'drawLinesBetweenIcons': {
                            const iconLayer = popup.querySelector('#iconLayerSelect').value;
                            const iconType = popup.querySelector('#iconType').value;
                            const maxDistance = parseFloat(popup.querySelector('#maxDistance').value);
                            const maxConnectionsPerIcon = parseInt(popup.querySelector('#maxConnectionsPerIcon').value, 10);
                            const minDistanceBetweenLines = parseFloat(popup.querySelector('#minDistanceBetweenLines').value);

                            if (!iconLayer || !iconType || isNaN(maxDistance) || isNaN(maxConnectionsPerIcon) || isNaN(minDistanceBetweenLines)) {
                                Swal.fire('Aviso', 'Preencha todos os campos corretamente.', 'warning');
                                return null;
                            }

                            return {
                                iconLayer,
                                iconType,
                                maxDistance,
                                maxConnectionsPerIcon,     // Novo parâmetro
                                minDistanceBetweenLines,  // Novo parâmetro
                                area: existingParameters.area || null
                            };
                        }

                        case 'connectDifferentIcons': {
                            const iconLayerConnect = popup.querySelector('#iconLayerSelect').value;
                            const iconType1 = popup.querySelector('#iconType1').value;
                            const iconType2 = popup.querySelector('#iconType2').value;
                            const maxDistanceConnect = parseFloat(popup.querySelector('#maxDistance').value);
                            const maxConnectionsSource = parseInt(popup.querySelector('#maxConnectionsSource').value);
                            const maxConnectionsTarget = parseInt(popup.querySelector('#maxConnectionsTarget').value);
                            const connectionCriterion = popup.querySelector('#connectionCriterion').value;

                            if (!iconLayerConnect || !iconType1 || !iconType2 || isNaN(maxDistanceConnect) || isNaN(maxConnectionsSource) || isNaN(maxConnectionsTarget) || !connectionCriterion) {
                                await Swal.fire('Aviso', 'Preencha todos os campos corretamente.', 'warning');
                                return null;
                            }

                            return {
                                iconLayer: iconLayerConnect,
                                iconType1,
                                iconType2,
                                maxDistance: maxDistanceConnect,
                                maxConnectionsSource,
                                maxConnectionsTarget,
                                connectionCriterion,
                                area: existingParameters.area || null
                            };
                        }

                        case 'drawCoverageArea': {
                            const iconUrlCoverage = popup.querySelector('#iconToInsert').value;
                            const radius = parseFloat(popup.querySelector('#radius').value);

                            // Obter a camada selecionada para os desenhos
                            const coverageLayer = popup.querySelector('#coverageLayerSelect').value;

                            // Obter os ícones selecionados para cobrir
                            const iconTypesToCoverSelect = popup.querySelector('#iconTypesToCover');
                            const selectedOptions = Array.from(iconTypesToCoverSelect.selectedOptions);
                            const iconTypesToCover = selectedOptions.map(option => option.value);

                            if (!iconUrlCoverage || isNaN(radius) || !coverageLayer) {
                                await Swal.fire('Aviso', 'Preencha todos os campos corretamente.', 'warning');
                                return null;
                            }

                            return {
                                iconUrl: iconUrlCoverage,
                                radius,
                                iconTypesToCover,
                                coverageLayer, // Adicionado
                                area: existingParameters.area || null
                            };
                        }


                        default:
                            Swal.fire('Erro', 'Tarefa desconhecida', 'error');
                            return null;
                                        }
                }


                async function executeTaskSequence() {

                    logMessages = '';
                    addToLog('Iniciando execução da sequência de tarefas.');

                    for (let i = 0; i < taskSequence.length; i++) {
                        const task = taskSequence[i];

                        addToLog(`Executando tarefa ${i + 1}: ${task.task} com parâmetros: ${JSON.stringify(task.parameters)}`);

                        try {
                            switch (task.task) {
                                case 'findHighestPoint':
                                    await performFindHighestPoint(task.parameters);
                                    break;

                                case 'placeIcons':
                                    await performPlaceIcons(task.parameters);
                                    break;

                                case 'drawLinesBetweenIcons':
                                    await performDrawLinesBetweenIcons(task.parameters);
                                    break;

                                case 'connectDifferentIcons':
                                    await performConnectDifferentIcons(task.parameters);
                                    break;

                                case 'drawCoverageArea':
                                    await performDrawCoverageArea(task.parameters);
                                    break;

                                default:
                                    addToLog('Erro: Tarefa desconhecida:', task.task);
                                    break;
                                             }

                            addToLog(`Tarefa ${i + 1} concluída.`);
                        } catch (error) {
                            console.error(`Erro na tarefa ${i + 1}:`, error);
                            await Swal.fire('Erro', `Ocorreu um erro na tarefa ${i + 1}: ${error.message}`, 'error');
                            return;
                        }

                        // Calcula o progresso atual
                        const progress = Math.round(((i + 1) / taskSequence.length) * 100);

                        // Exibe um toast com a porcentagem de progresso
                        Swal.fire({
                            toast: true,
                            position: 'top-end',
                            icon: 'info', // Você pode mudar o ícone conforme a necessidade
                            title: `Progresso: ${progress}%`,
                            showConfirmButton: false,
                            timer: 500, // Fecha automaticamente após 500ms
                            timerProgressBar: false,
                            background: '#fff', // Define o fundo da toast (opcional)
                            // Customizações adicionais podem ser feitas aqui
                        });
                    }

                    // Exibe a mensagem de conclusão
                    addToLog('Planejamento concluído e salvo na camada "Sugestão de Planejamento".');

                    // Função para formatar o log, destacando linhas com "Erro:" em negrito
                    function formatLog(log) {
                        // Dividir o log em linhas
                        const lines = log.split('\n');
                        // Mapear cada linha, aplicando negrito se contiver "Erro:"
                        const formattedLines = lines.map(line => {
                            if (line.includes('Erro:')) {
                                return `<strong>${line}</strong>`;
                            }
                            return line;
                        });
                        // Unir as linhas novamente
                        return formattedLines.join('<br>');
                    }

                    // Função para verificar se existem erros no log
                    function hasErrors(log) {
                        return log.includes('Erro:');
                    }

                    console.warn(logMessages);

                    // Modal de Planejamento Concluído aprimorado
                    await Swal.fire({
                        title: hasErrors(logMessages) ? 'Planejamento concluído com erros' : 'Planejamento concluído com sucesso',
                        html: `
<div style="max-height: 300px; overflow-y: auto; text-align: left; white-space: pre-line; margin-bottom: 20px;">
${formatLog(logMessages)}
            </div>
${!hasErrors(logMessages) ? "<p>Planejamento salvo na camada 'Sugestão de Planejamento'.</p>" : ""}
`,
                        icon: hasErrors(logMessages) ? 'warning' : 'success',
                        showCancelButton: true,
                        cancelButtonText: '<i class="fa fa-copy"></i> Copiar Log',
                        confirmButtonText: 'OK',
                        reverseButtons: true,
                        preConfirm: () => {
                            // Nenhuma ação específica ao confirmar
                        },
                        didOpen: () => {
                            const copyButton = Swal.getCancelButton();
                            copyButton.addEventListener('click', () => {
                                // Copiar o log para a área de transferência
                                navigator.clipboard.writeText(logMessages).then(() => {
                                    Swal.fire({
                                        title: 'Sucesso',
                                        text: 'Log copiado para a área de transferência.',
                                        icon: 'success',
                                        timer: 2000,
                                        showConfirmButton: false
                                    });
                                }).catch(err => {
                                    Swal.fire('Erro', 'Não foi possível copiar o log.', 'error');
                                });
                            });
                        }
                    });

                }







                // Função global para obter dados de elevação, com tratamento de erros e opção de upload
                async function fetchElevationData(bounds) {
                    try {
                        const response = await fetch(`get_elevation_data.php?minLat=${bounds.getSouth()}&maxLat=${bounds.getNorth()}&minLon=${bounds.getWest()}&maxLon=${bounds.getEast()}`);

                        if (!response.ok) {
                            const errorData = await response.json();

                            if (errorData.error === 'Arquivos de elevação faltando' && errorData.missingTiles) {
                                // Mostrar mensagem de erro e oferecer opção de upload
                                const missingTiles = errorData.missingTiles;
                                const tileList = missingTiles.join(', ');
                                const { isConfirmed } = await Swal.fire({
                                    title: 'Arquivos de Elevação Faltando',
                                    html: `Os seguintes arquivos de elevação estão faltando: <b>${tileList}</b><br>Você pode obtê-los através do site <a href="https://dwtkns.com/srtm30m/" target="_blank">SRTM30</a><br>Deseja fazer o upload dos arquivos faltantes?`,
                                    icon: 'error',
                                    showCancelButton: true,
                                    confirmButtonText: 'Fazer Upload',
                                    cancelButtonText: 'Cancelar'
                                });

                                if (isConfirmed) {
                                    // Mostrar formulário para upload
                                    const { value: uploadData } = await Swal.fire({
                                        title: 'Upload de Arquivos de Elevação',
                                        html: `
<p>Por favor, selecione os arquivos correspondentes aos tiles faltantes.</p>
${missingTiles.map(tile => `<label>${tile}: <input type="file" id="file_${tile}" accept=".hgt"></label><br>`).join('')}
`,
                                        focusConfirm: false,
                                        preConfirm: () => {
                                            const formData = new FormData();
                                            let allFilesSelected = true;
                                            missingTiles.forEach(tile => {
                                                const fileInput = document.getElementById(`file_${tile}`);
                                                if (!fileInput || fileInput.files.length === 0) {
                                                    allFilesSelected = false;
                                                } else {
                                                    formData.append('files[]', fileInput.files[0], fileInput.files[0].name.toUpperCase());
                                                }
                                                // Adicionar missingTiles ao FormData
                                                formData.append('missingTiles', JSON.stringify(missingTiles));

                                            });
                                            if (!allFilesSelected) {
                                                Swal.showValidationMessage('Você deve selecionar todos os arquivos.');
                                                return false;
                                            }
                                            return formData;
                                        },
                                        showCancelButton: true,
                                        confirmButtonText: 'Enviar',
                                        cancelButtonText: 'Cancelar'
                                    });

                                    if (uploadData) {
                                        // Enviar os arquivos ao servidor
                                        try {
                                            // **Adicionar** a barra de progresso falsa antes do upload
                                            Swal.fire({
                                                title: 'Enviando arquivo(s)',
                                                html: `
<div style="width: 100%; background-color: #ddd; border-radius: 5px; overflow: hidden; margin-top: 20px;">
<div id="fake-progress" style="width: 0%; height: 20px; background-color: #4caf50;"></div>
            </div>
<p style="margin-top: 10px;">Por favor, aguarde...</p>
`,
                                                allowOutsideClick: false,
                                                showConfirmButton: false,
                                                didOpen: () => {
                                                    const progressBar = Swal.getPopup().querySelector('#fake-progress');
                                                    let progress = 0;
                                                    // Simular o progresso até 90%
                                                    window.fakeProgressInterval = setInterval(() => {
                                                        if (progress < 95) {
                                                            // Incremento aleatório entre 0.5% e 1%
                                                            progress += (Math.random() * 0.4) + 0.5;
                                                            if (progress > 90) progress = 90; // Limitar a 90%
                                                            progressBar.style.width = progress.toFixed(2) + '%';
                                                        } else {
                                                            clearInterval(window.fakeProgressInterval);
                                                        }
                                                    }, 1000); // Atualizar a cada 1 segundo

                                                }
                                            });

                                            const uploadResponse = await fetch('upload_elevation_files.php', {
                                                method: 'POST',
                                                body: uploadData
                                            });

                                            // **Atualizar** a barra de progresso para 100% após a conclusão do upload
                                            const progressBar = Swal.getPopup().querySelector('#fake-progress');
                                            progressBar.style.width = '100%';
                                            clearInterval(window.fakeProgressInterval);

                                            const uploadResult = await uploadResponse.json();

                                            if (uploadResult.success) {
                                                Swal.fire('Sucesso', 'Arquivos enviados com sucesso. Tentando novamente obter os dados de elevação...', 'success');
                                                addToLog('Arquivos de elevação enviados com sucesso.');
                                                console.warn("Arquivos de elevação enviados com sucesso.");

                                                // Tentar novamente obter os dados de elevação
                                                return await fetchElevationData(bounds);
                                            } else {
                                                Swal.fire('Erro', uploadResult.message || 'Falha ao enviar os arquivos de elevação.', 'error');
                                                addToLog('Erro: Falha ao enviar os arquivos de elevação:', uploadResult.message);
                                                console.warn("Falha ao enviar os arquivos de elevação");
                                                return null;
                                            }
                                        } catch (uploadError) {
                                            Swal.fire('Erro', 'Erro ao enviar os arquivos de elevação.', 'error');
                                            addToLog('Erro ao enviar os arquivos de elevação:', uploadError);
                                            console.warn("Erro ao enviar os arquivos de elevação.");
                                            return null;
                                        }
                                    } else {
                                        // Usuário cancelou o upload
                                        Swal.fire('Aviso', 'Operação cancelada pelo usuário.', 'warning');
                                        return null;
                                    }


                                } else {
                                    // Usuário cancelou a ação
                                    return null;
                                }
                            } else {
                                addToLog('Erro ao obter dados de elevação:', errorData.error);
                                console.warn("Erro ao obter os dados de elevação.");
                                return null;
                            }
                        } else {
                            const elevationData = await response.json();

                            if (!Array.isArray(elevationData) || elevationData.length === 0) {
                                addToLog('Erro: Dados de elevação inválidos ou vazios.');
                                console.warn("Erro: Dados de elevação inválidos ou vazios");
                                return null;
                            }

                            Swal.close();
                            return elevationData;
                        }
                    } catch (error) {
                        addToLog('Erro ao obter os dados de elevação:', error);
                        console.warn("Erro ao obter os dados de elevação.");
                        return null;
                    }
                }




                // Função para executar a tarefa de encontrar o ponto mais alto
                async function performFindHighestPoint(params) {
                    const iconLayerName = params.iconLayer;
                    const iconType = params.iconType;
                    const maxDistance = params.maxDistance * 1000; // Converter km para metros
                    const selectedIconUrl = params.iconToInsert;
                    let selectionArea = params.area;
                    const numberOfNewIcons = params.numberOfNewIcons; // Novo parâmetro
                    const maxDistanceBetweenNewIcons = params.maxDistanceBetweenNewIcons * 1000; // Converter km para metros

                    addToLog('Iniciando tarefa: Encontrar o ponto mais alto próximo a um ícone', params);
                    //addToLog(`Iniciando tarefa: Encontrar o ponto mais alto com parâmetros: ${JSON.stringify(params)}`);
                    //addToLog(`Parâmetros antes de executar performFindHighestPoint: ${JSON.stringify(params)}`);

                    // Obter a camada selecionada para buscar os ícones existentes
                    let iconLayer;
                    if (iconLayerName === 'drawnItems') {
                        iconLayer = drawnItems;
                    } else if (iconLayerName === 'planningSuggestions') {
                        iconLayer = planejamentoLayer;
                    } else {
                        addToLog('Erro: Camada de origem dos ícones inválida:', iconLayerName);
                        return;
                    }

                    // Se a área de seleção for nula, considerar os limites atuais do mapa
                    if (!selectionArea) {
                        selectionArea = map.getBounds();
                    }

                    // Obter todos os ícones do tipo especificado na camada selecionada dentro da área de seleção
                    const icons = [];
                    iconLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Marker && layer.options.icon && layer.options.icon.options.iconUrl) {
                            const iconUrl = layer.options.icon.options.iconUrl;

                            let isInArea = false;
                            if (selectionArea instanceof L.LatLngBounds) {
                                isInArea = selectionArea.contains(layer.getLatLng());
                            } else if (selectionArea instanceof L.Polygon) {
                                isInArea = selectionArea.contains(layer.getLatLng());
                            }

                            if (iconUrl === iconType && isInArea) {
                                icons.push(layer);
                            }
                        }
                    });

                    if (icons.length === 0) {
                        addToLog(`Erro: Nenhum ícone do tipo ${iconType} encontrado na área selecionada.`);
                        return;
                    }

                    // Obter os limites da área de seleção
                    let bounds;
                    if (selectionArea instanceof L.LatLngBounds) {
                        bounds = selectionArea;
                    } else if (selectionArea instanceof L.Polygon) {
                        bounds = selectionArea.getBounds();
                    }



                    // Chamar a função para obter os dados de elevação
                    addToLog('Buscando dados de altura com limites:', bounds);

                    const elevationData = await fetchElevationData(bounds);

                    if (!elevationData) {
                        addToLog('Erro: Dados de elevação inválidos ou vazios.');
                        return;
                    }


                    // Para cada ícone, encontrar o ponto mais alto próximo
                    for (const icon of icons) {
                        const iconLatLng = icon.getLatLng();

                        // Filtrar pontos dentro da distância máxima e dentro da área de seleção
                        const nearbyPoints = elevationData.filter(point => {
                            const pointLatLng = L.latLng(point.lat, point.lon);
                            const distance = map.distance(iconLatLng, pointLatLng);

                            let isInArea = false;
                            if (selectionArea instanceof L.LatLngBounds) {
                                isInArea = selectionArea.contains(pointLatLng);
                            } else if (selectionArea instanceof L.Polygon) {
                                isInArea = selectionArea.contains(pointLatLng);
                            }

                            return distance <= maxDistance && isInArea;
                        });

                        if (nearbyPoints.length === 0) {
                            addToLog(`Erro: Nenhum ponto próximo encontrado para o ícone em ${iconLatLng}`);
                            continue;
                        }

                        // Encontrar o ponto com a maior elevação
                        const highestPoint = nearbyPoints.reduce((prev, current) => (prev.elevation > current.elevation) ? prev : current);

                        // Adicionar um marcador no ponto mais alto encontrado com o ícone selecionado
                        const marker = L.marker([highestPoint.lat, highestPoint.lon], {
                            icon: L.icon({
                                iconUrl: selectedIconUrl,
                                iconSize: [32, 32],
                                iconAnchor: [16, 32],
                                popupAnchor: [0, -32]
                            })
                        }).bindPopup(`Ponto mais alto próximo a ${iconType}<br>Elevação: ${highestPoint.elevation} metros`);

                        // Adiciona propriedades personalizadas
                        marker.feature = {
                            type: "Feature",
                            properties: {
                                folderName: "Sugestão de Planejamento",
                                name: "Ponto Mais Alto",
                                description: `Elevação: ${highestPoint.elevation} metros`,
                                iconUrl: selectedIconUrl,
                                color: "#FF0000"
                            }
                        };

                        planejamentoLayer.addLayer(marker);
                    }

                    // **Adiciona Novos Ícones**
                    if (params.numberOfNewIcons > 0) {

                        // Função para gerar posições aleatórias dentro dos limites da área de seleção
                        function getRandomLatLng(bounds) {
                            const southWest = bounds.getSouthWest();
                            const northEast = bounds.getNorthEast();

                            const lat = southWest.lat + Math.random() * (northEast.lat - southWest.lat);
                            const lng = southWest.lng + Math.random() * (northEast.lng - southWest.lng);
                            return L.latLng(lat, lng);
                        }

                        const newIcons = [];

                        while (newIcons.length <= numberOfNewIcons-2) {
                            const randomLatLng = getRandomLatLng(bounds);

                            // Verifica se a nova posição está dentro da distância máxima de outros novos ícones
                            const tooClose = newIcons.some(existingIcon => {
                                const distance = map.distance(randomLatLng, existingIcon);
                                return distance < maxDistanceBetweenNewIcons;
                            });

                            if (!tooClose) {
                                newIcons.push(randomLatLng);
                            }

                            // Evita loops infinitos caso não seja possível encontrar posições adequadas
                            if (newIcons.length + (numberOfNewIcons - newIcons.length) > numberOfNewIcons * 10) {
                                addToLog('Erro: Não foi possível encontrar posições adequadas para todos os novos ícones.');
                                break;
                            }
                        }

                        // Adicionar os novos ícones ao mapa
                        newIcons.forEach(latlng => {
                            const newMarker = L.marker(latlng, {
                                icon: L.icon({
                                    iconUrl: selectedIconUrl,
                                    iconSize: [32, 32],
                                    iconAnchor: [16, 32],
                                    popupAnchor: [0, -32]
                                })
                            }).bindPopup(`Novo Ícone Adicionado<br>Coordenadas: ${latlng.lat.toFixed(5)}, ${latlng.lng.toFixed(5)}`);

                            // Adiciona propriedades personalizadas
                            newMarker.feature = {
                                type: "Feature",
                                properties: {
                                    folderName: "Sugestão de Planejamento",
                                    name: "Novo Ícone",
                                    description: `Coordenadas: ${latlng.lat.toFixed(5)}, ${latlng.lng.toFixed(5)}`,
                                    iconUrl: selectedIconUrl,
                                    color: "#00FF00"
                                }
                            };

                            planejamentoLayer.addLayer(newMarker);
                        });
                        Swal.close();
                        addToLog(`Tarefa concluída: ${newIcons.length} novos ícones adicionados ao mapa.`);
                    } else {
                        Swal.close();
                        addToLog('Tarefa concluída: Pontos mais altos adicionados ao mapa.');
                    }
                }


                // Função para executar a tarefa de colocar múltiplos ícones
                async function performPlaceIcons(params) {
                    const iconUrl = params.iconUrl;
                    const elevationMin = params.criteria;
                    const maxNumberOfIcons = params.maxNumberOfIcons;             // Novo parâmetro
                    const minDistanceBetweenIcons = params.minDistanceBetweenIcons; // Novo parâmetro
                    let selectionArea = params.area;

                    addToLog('Iniciando tarefa: Colocar múltiplos ícones', params);

                    // Se a área de seleção for nula, considerar os limites atuais do mapa
                    if (!selectionArea) {
                        selectionArea = map.getBounds();
                    }

                    // Obter os limites da área de seleção
                    let bounds;
                    if (selectionArea instanceof L.LatLngBounds) {
                        bounds = selectionArea;
                    } else if (selectionArea instanceof L.Polygon) {
                        bounds = selectionArea.getBounds();
                    }

                    try {
                        const elevationData = await fetchElevationData(bounds);

                        if (!elevationData) {
                            return;
                        }


                        if (!Array.isArray(elevationData) || elevationData.length === 0) {
                            await Swal.fire('Erro', 'Não foi possível obter os dados de elevação.', 'error');
                            console.error('Dados de elevação inválidos ou vazios.');
                            return;
                        }

                        Swal.close();

                        // Filtrar os pontos que atendem ao critério de elevação mínima e estão dentro da área de seleção
                        const suitablePoints = elevationData.filter(point => {
                            let isInArea = false;
                            const pointLatLng = L.latLng(point.lat, point.lon);

                            if (selectionArea instanceof L.LatLngBounds) {
                                isInArea = selectionArea.contains(pointLatLng);
                            } else if (selectionArea instanceof L.Polygon) {
                                isInArea = selectionArea.contains(pointLatLng);
                            }

                            return point.elevation >= elevationMin && isInArea;
                        });

                        if (suitablePoints.length === 0) {
                            addToLog('Erro: Nenhum ponto atende ao critério de elevação mínima na área selecionada.');
                            return;
                        }

                        // Ordenar os pontos por elevação descendente para priorizar os mais altos
                        suitablePoints.sort((a, b) => b.elevation - a.elevation);

                        // Limitar a quantidade de ícones conforme o parâmetro
                        const pointsToPlace = suitablePoints.slice(0, maxNumberOfIcons);

                        // Array para armazenar as coordenadas dos ícones já inseridos
                        const placedIcons = [];

                        for (const point of pointsToPlace) {
                            const pointLatLng = L.latLng(point.lat, point.lon);

                            // Verificar a distância mínima entre os ícones já colocados
                            const tooClose = placedIcons.some(existingLatLng => {
                                const distance = map.distance(existingLatLng, pointLatLng);
                                return distance < minDistanceBetweenIcons;
                            });

                            if (tooClose) {
                                console.warn(`Ícone em ${pointLatLng} está muito próximo de outro ícone já inserido. Ignorado.`);
                                continue;
                            }

                            // Adicionar o ícone no mapa
                            const marker = L.marker([point.lat, point.lon], {
                                icon: L.icon({
                                    iconUrl: iconUrl,
                                    iconSize: [32, 32],
                                    iconAnchor: [16, 32],
                                    popupAnchor: [0, -32]
                                })
                            }).bindPopup(`Ícone inserido<br>Elevação: ${point.elevation} metros`);

                            // Adiciona propriedades personalizadas
                            marker.feature = {
                                type: "Feature",
                                properties: {
                                    folderName: "Sugestão de Planejamento",
                                    name: `Ícone Inserido`,
                                    description: `Elevação: ${point.elevation} metros`,
                                    iconUrl: iconUrl,
                                    color: "#FF0000"
                                }
                            };

                            planejamentoLayer.addLayer(marker);
                            placedIcons.push(pointLatLng); // Atualizar a lista de coordenadas
                        }

                        // Verificar se todos os ícones solicitados foram inseridos
                        const iconsPlaced = placedIcons.length;
                        if (iconsPlaced < maxNumberOfIcons) {
                            addToLog(`Apenas ${iconsPlaced} ícones foram inseridos devido às restrições de distância.`);
                        } else {
                            addToLog(`Tarefa concluída: ${iconsPlaced} ícones adicionados ao mapa.`);
                        }

                    } catch (error) {
                        console.error('Erro ao processar a tarefa:', error);
                        await Swal.fire('Erro', 'Ocorreu um erro ao processar a tarefa.', 'error');
                    }
                }



                // Função para executar a tarefa de desenhar linhas entre ícones do mesmo tipo
                async function performDrawLinesBetweenIcons(params) {
                    const iconType = params.iconType;
                    const maxDistance = params.maxDistance * 1000; // Converter km para metros
                    const maxConnectionsPerIcon = params.maxConnectionsPerIcon; // Novo parâmetro
                    const minDistanceBetweenLines = params.minDistanceBetweenLines; // Novo parâmetro
                    let selectionArea = params.area; // Pode ser nulo

                    addToLog('Iniciando tarefa: Desenhar linhas entre ícones', params);

                    // Obter a camada selecionada para buscar os ícones existentes
                    let iconLayer;
                    if (params.iconLayer === 'drawnItems') {
                        iconLayer = drawnItems;
                    } else if (params.iconLayer === 'planningSuggestions') {
                        iconLayer = planejamentoLayer;
                    } else {
                        await Swal.fire('Erro', 'Camada de origem dos ícones inválida.', 'error');
                        console.error('Camada de origem dos ícones inválida:', params.iconLayer);
                        return;
                    }

                    // Se a área de seleção for nula, considerar os limites atuais do mapa
                    if (!selectionArea) {
                        selectionArea = map.getBounds(); // Agora é um L.LatLngBounds
                    }

                    // Obter todos os ícones do tipo especificado dentro da área selecionada
                    const icons = [];
                    iconLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Marker && layer.options.icon && layer.options.icon.options.iconUrl) {

                            const iconUrl = layer.options.icon.options.iconUrl;
                            //const iconNameWithExtension = iconUrl.substring(iconUrl.lastIndexOf('/') + 1);
                            //const iconName = iconNameWithExtension.split('.')[0]; // Remove a extensão do arquivo

                            let isInArea = false;
                            if (selectionArea instanceof L.LatLngBounds) {
                                isInArea = selectionArea.contains(layer.getLatLng());
                            } else if (selectionArea instanceof L.Polygon) {
                                isInArea = selectionArea.contains(layer.getLatLng());
                            }

                            if (iconUrl === iconType && isInArea) {
                                icons.push(layer);
                            }
                        }
                    });

                    if (icons.length < 2) {
                        addToLog(`Erro: Não há ícones suficientes do tipo ${iconType} na área selecionada para desenhar linhas.`);
                        return;
                    }

                    // Criar todas as combinações possíveis de pares de ícones
                    const potentialLines = [];
                    for (let i = 0; i < icons.length; i++) {
                        for (let j = i + 1; j < icons.length; j++) {
                            const latlng1 = icons[i].getLatLng();
                            const latlng2 = icons[j].getLatLng();
                            const distance = map.distance(latlng1, latlng2);

                            if (distance <= maxDistance) {
                                potentialLines.push({
                                    from: icons[i],
                                    to: icons[j],
                                    distance
                                });
                            }
                        }
                    }

                    if (potentialLines.length === 0) {
                        addToLog(`Erro: Nenhuma conexão encontrada entre ícones do tipo ${iconType} dentro da distância máxima especificada.`);
                        return;
                    }

                    // Ordenar as linhas potenciais pela distância (opcional, para priorizar conexões mais próximas)
                    potentialLines.sort((a, b) => a.distance - b.distance);

                    // Controle de conexões por ícone
                    const connectionCount = {};
                    icons.forEach(icon => {
                        connectionCount[icon._leaflet_id] = 0;
                    });

                    // Lista de linhas já desenhadas para verificar a distância mínima entre elas
                    const linesDrawn = [];

                    for (const line of potentialLines) {
                        const fromId = line.from._leaflet_id;
                        const toId = line.to._leaflet_id;

                        // Verificar se os ícones já atingiram o número máximo de conexões
                        if (connectionCount[fromId] >= maxConnectionsPerIcon || connectionCount[toId] >= maxConnectionsPerIcon) {
                            continue;
                        }

                        // Criar uma linha temporária para verificar a distância mínima com linhas já desenhadas
                        const tempPolyline = L.polyline([line.from.getLatLng(), line.to.getLatLng()]);
                        let isTooClose = false;

                        for (const existingLine of linesDrawn) {
                            // Verificar se as linhas compartilham algum ícone comum
                            const existingLatLngs = existingLine.getLatLngs();
                            const existingFrom = existingLatLngs[0];
                            const existingTo = existingLatLngs[1];
                            const newFrom = line.from.getLatLng();
                            const newTo = line.to.getLatLng();

                            const shareFrom = (existingFrom.lat === newFrom.lat && existingFrom.lng === newFrom.lng) ||
                                  (existingFrom.lat === newTo.lat && existingFrom.lng === newTo.lng);
                            const shareTo = (existingTo.lat === newFrom.lat && existingTo.lng === newFrom.lng) ||
                                  (existingTo.lat === newTo.lat && existingTo.lng === newTo.lng);

                            if (shareFrom || shareTo) {
                                // Linhas compartilham um ícone comum, não verificar distância mínima entre elas
                                continue;
                            }

                            // Calcular a distância mínima entre as duas polilinhas
                            const distance = polylineDistance(tempPolyline, existingLine);
                            if (distance < minDistanceBetweenLines) {
                                isTooClose = true;
                                break;
                            }
                        }

                        if (isTooClose) {
                            continue;
                        }

                        // Desenhar a linha entre os ícones
                        const polyline = L.polyline([line.from.getLatLng(), line.to.getLatLng()], { color: 'blue' });
                        polyline.addTo(planejamentoLayer);

                        // Adicionar propriedades personalizadas
                        polyline.feature = {
                            type: "Feature",
                            properties: {
                                folderName: "Sugestão de Planejamento",
                                name: "Linha entre Ícones",
                                description: `Linha entre ${iconType}`,
                                color: "#0000FF"
                            }
                        };

                        // Atualizar contagem de conexões
                        connectionCount[fromId]++;
                        connectionCount[toId]++;

                        // Adicionar a linha à lista de linhas desenhadas
                        linesDrawn.push(polyline);
                    }

                    // Função para calcular a distância mínima entre duas polilinhas
                    function polylineDistance(polyline1, polyline2) {
                        const latlngs1 = polyline1.getLatLngs();
                        const latlngs2 = polyline2.getLatLngs();
                        let minDistance = Infinity;

                        latlngs1.forEach((latlng1) => {
                            latlngs2.forEach((latlng2) => {
                                const distance = map.distance(latlng1, latlng2);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                }
                            });
                        });

                        return minDistance;
                    }

                    addToLog(`Tarefa concluída: ${linesDrawn.length} linhas desenhadas entre ícones do tipo ${iconType}.`);
                }



                // Função para executar a tarefa de conectar ícones diferentes com linhas
                async function performConnectDifferentIcons(params) {
                    const iconLayerName = params.iconLayer;
                    const iconType1 = params.iconType1;
                    const iconType2 = params.iconType2;
                    const maxDistance = params.maxDistance * 1000; // Converter km para metros
                    const maxConnectionsSource = params.maxConnectionsSource;
                    const maxConnectionsTarget = params.maxConnectionsTarget;
                    const connectionCriterion = params.connectionCriterion; // 'closest' ou 'farthest'
                    let selectionArea = params.area;

                    addToLog('Iniciando tarefa: Conectar ícones diferentes com linhas', params);

                    // Obter a camada selecionada para buscar os ícones existentes
                    let iconLayer;
                    if (iconLayerName === 'drawnItems') {
                        iconLayer = drawnItems;
                    } else if (iconLayerName === 'planningSuggestions') {
                        iconLayer = planejamentoLayer;
                    } else {
                        await Swal.fire('Erro', 'Camada de origem dos ícones inválida.', 'error');
                        console.error('Camada de origem dos ícones inválida:', iconLayerName);
                        return;
                    }

                    // Se a área de seleção for nula, considerar os limites atuais do mapa
                    if (!selectionArea) {
                        selectionArea = map.getBounds();
                    }

                    // Obter os ícones do tipo 1 (ícones fonte)
                    const icons1 = [];
                    iconLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Marker && layer.options.icon && layer.options.icon.options.iconUrl) {

                            const iconUrl = layer.options.icon.options.iconUrl;
                            //const iconNameWithExtension = iconUrl.substring(iconUrl.lastIndexOf('/') + 1);
                            //const iconName = iconNameWithExtension.split('.')[0];

                            let isInArea = false;
                            if (selectionArea instanceof L.LatLngBounds) {
                                isInArea = selectionArea.contains(layer.getLatLng());
                            } else if (selectionArea instanceof L.Polygon) {
                                isInArea = selectionArea.contains(layer.getLatLng());
                            }

                            if (iconUrl === iconType1 && isInArea) {
                                icons1.push(layer);
                            }
                        }
                    });

                    // Obter os ícones do tipo 2 (ícones alvo)
                    const icons2 = [];
                    iconLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Marker && layer.options.icon && layer.options.icon.options.iconUrl) {

                            const iconUrl = layer.options.icon.options.iconUrl;
                            //const iconNameWithExtension = iconUrl.substring(iconUrl.lastIndexOf('/') + 1);
                            //const iconName = iconNameWithExtension.split('.')[0];

                            let isInArea = false;
                            if (selectionArea instanceof L.LatLngBounds) {
                                isInArea = selectionArea.contains(layer.getLatLng());
                            } else if (selectionArea instanceof L.Polygon) {
                                isInArea = selectionArea.contains(layer.getLatLng());
                            }

                            if (iconUrl === iconType2 && isInArea) {
                                icons2.push(layer);
                            }
                        }
                    });

                    if (icons1.length === 0 || icons2.length === 0) {
                        addToLog('Erro: Não há ícones suficientes para conectar os ícones.');
                        return;
                    }

                    // Mapear quantas conexões cada ícone alvo já recebeu
                    const targetIconConnections = new Map();

                    const linesDrawn = [];

                    // Para cada ícone fonte (icon1), encontrar ícones alvo (icon2) dentro da distância máxima
                    for (let i = 0; i < icons1.length; i++) {
                        const icon1 = icons1[i];
                        const icon1LatLng = icon1.getLatLng();

                        // Lista de potenciais ícones alvo com a distância
                        const potentialTargets = [];

                        for (let j = 0; j < icons2.length; j++) {
                            const icon2 = icons2[j];
                            const icon2LatLng = icon2.getLatLng();
                            const distance = map.distance(icon1LatLng, icon2LatLng);

                            if (distance <= maxDistance) {
                                potentialTargets.push({
                                    icon: icon2,
                                    distance: distance
                                });
                            }
                        }

                        if (potentialTargets.length === 0) {
                            continue; // Nenhum ícone alvo dentro da distância máxima
                        }

                        // Ordenar os potenciais alvos de acordo com o critério
                        if (connectionCriterion === 'closest') {
                            potentialTargets.sort((a, b) => a.distance - b.distance); // Mais próximos primeiro
                        } else if (connectionCriterion === 'farthest') {
                            potentialTargets.sort((a, b) => b.distance - a.distance); // Mais distantes primeiro
                        }

                        // Conectar com até maxConnectionsSource ícones alvo
                        let connectionsMade = 0;

                        for (let k = 0; k < potentialTargets.length && connectionsMade < maxConnectionsSource; k++) {
                            const target = potentialTargets[k];
                            const icon2 = target.icon;

                            // Verificar se o ícone alvo não ultrapassou o máximo de conexões
                            const icon2Id = L.stamp(icon2); // ID único para cada layer
                            const icon2Connections = targetIconConnections.get(icon2Id) || 0;

                            if (icon2Connections < maxConnectionsTarget) {
                                // Desenhar linha entre icon1 e icon2
                                const polyline = L.polyline([icon1LatLng, icon2.getLatLng()], { color: 'green' });
                                polyline.addTo(planejamentoLayer);

                                // Adicionar propriedades personalizadas
                                polyline.feature = {
                                    type: "Feature",
                                    properties: {
                                        folderName: "Sugestão de Planejamento",
                                        name: "Linha entre Ícones Diferentes",
                                        description: `Linha entre ${iconType1} e ${iconType2}`,
                                        color: "#00FF00"
                                    }
                                };

                                linesDrawn.push(polyline);

                                // Atualizar contador de conexões
                                targetIconConnections.set(icon2Id, icon2Connections + 1);

                                connectionsMade++;
                            }
                        }
                    }

                    addToLog(`Tarefa concluída: ${linesDrawn.length} linhas desenhadas entre ícones diferentes.`);
                }

                // Função para executar a tarefa de desenhar áreas de cobertura otimizadas
                async function performDrawCoverageArea(params) {
                    const iconUrl = params.iconUrl;
                    const radiusKm = params.radius;
                    const iconTypesToCover = params.iconTypesToCover;
                    const coverageLayerName = params.coverageLayer; // Adicionado
                    let selectionArea = params.area;

                    addToLog('Iniciando tarefa: Desenhar áreas de cobertura com ícone central', params);

                    // Obter a camada selecionada com base no nome
                    const coverageLayer = planejamentoLayer;


                    addToLog('Desenhos serão adicionados à camada: Sugestão de Planejamento');


                    addToLog(`Camada selecionada para cobertura: ${coverageLayerName}`);

                    // Se a área de seleção for nula, considerar os limites atuais do mapa
                    if (!selectionArea) {
                        selectionArea = map.getBounds();
                        addToLog('Área de seleção é nula, usando map.getBounds():', selectionArea);
                    } else {
                        addToLog('Área de seleção fornecida:', selectionArea);
                    }

                    // Definir as camadas onde os ícones podem estar
                    const layersToSearch = [drawnItems, planejamentoLayer];

                    // Obter todos os ícones que precisam ser cobertos
                    const iconsToCover = [];

                    layersToSearch.forEach(layerGroup => {
                        layerGroup.eachLayer(function(layer) {
                            if (layer instanceof L.Marker && layer.options.icon && layer.options.icon.options.iconUrl) {
                                const layerIconUrl = layer.options.icon.options.iconUrl;
                                //const iconNameWithExtension = layerIconUrl.substring(layerIconUrl.lastIndexOf('/') + 1);
                                //const iconName = iconNameWithExtension.split('.')[0];

                                let isInArea = false;

                                if (selectionArea instanceof L.LatLngBounds) {
                                    isInArea = selectionArea.contains(layer.getLatLng());
                                } else if (selectionArea instanceof L.Polygon) {
                                    isInArea = selectionArea.contains(layer.getLatLng());
                                }

                                if (iconTypesToCover.includes(layerIconUrl) && isInArea) {
                                    iconsToCover.push({
                                        marker: layer,
                                        latlng: layer.getLatLng()
                                    });
                                }
                            }
                        });
                    });

                    addToLog(`Total de ícones a serem cobertos: ${iconsToCover.length}`);

                    if (iconsToCover.length === 0) {
                        addToLog('Erro: Nenhum ícone para cobrir na área selecionada.');
                        return;
                    }

                    const radiusMeters = radiusKm * 1000;

                    // Converter os pontos dos ícones em um array de coordenadas
                    const points = iconsToCover.map(icon => [icon.latlng.lat, icon.latlng.lng]);

                    // Configurar o DBSCAN com ajustes
                    const clustering = new DBSCAN();
                    const minPts = 1; // Permitir clusters de tamanho 1
                    const epsilon = radiusMeters; // Ajustado para radiusMeters para garantir que cada cluster possa ser coberto por um círculo de raio R

                    const clusters = clustering.run(points, epsilon, minPts, function(p, q) {
                        // Função de distância esférica (Haversine)
                        const R = 6371000; // Raio da Terra em metros
                        const lat1 = p[0] * Math.PI / 180;
                        const lat2 = q[0] * Math.PI / 180;
                        const deltaLat = (q[0] - p[0]) * Math.PI / 180;
                        const deltaLon = (q[1] - p[1]) * Math.PI / 180;

                        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                              Math.cos(lat1) * Math.cos(lat2) *
                              Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                        return R * c;
                    });

                    addToLog('Clusters formados pelo DBSCAN:', clusters);

                    // Conjunto para rastrear quais ícones já estão cobertos
                    const coveredIcons = new Set();

                    // Array para armazenar todas as coverage circles
                    const coverageCircles = [];

                    // Função para calcular a distância entre dois pontos em metros
                    function calculateDistance(latlng1, latlng2) {
                        return map.distance(latlng1, latlng2);
                    }

                    // Função para obter os centróides potenciais (usando grade ou centroides)
                    function generatePotentialCentroids(icons, clusterBounds, gridSizeKm = 1) {
                        const gridSize = gridSizeKm / 111; // Aproximadamente 1 km em graus (varia com a latitude)
                        const minLat = clusterBounds.minLat;
                        const maxLat = clusterBounds.maxLat;
                        const minLon = clusterBounds.minLon;
                        const maxLon = clusterBounds.maxLon;

                        const centroids = [];

                        for (let lat = minLat; lat <= maxLat; lat += gridSize) {
                            for (let lon = minLon; lon <= maxLon; lon += gridSize) {
                                centroids.push(L.latLng(lat, lon));
                            }
                        }

                        return centroids;
                    }

                    // Variável para armazenar todos os dados de elevação
                    let allElevationData = [];

                    // Obter os limites da área de seleção para buscar todos os dados de elevação necessários
                    let minLatSelection, maxLatSelection, minLonSelection, maxLonSelection;

                    if (selectionArea instanceof L.LatLngBounds) {
                        minLatSelection = selectionArea.getSouth();
                        maxLatSelection = selectionArea.getNorth();
                        minLonSelection = selectionArea.getWest();
                        maxLonSelection = selectionArea.getEast();
                    } else if (selectionArea instanceof L.Polygon) {
                        const bounds = selectionArea.getBounds();
                        minLatSelection = bounds.getSouth();
                        maxLatSelection = bounds.getNorth();
                        minLonSelection = bounds.getWest();
                        maxLonSelection = bounds.getEast();
                    }

                    try {
                        // Criar um objeto bounds com base nas seleções atuais
                        addToLog('Solicitando dados de elevação para os limites:', selectionArea);

                        // Chamar a função fetchElevationData em vez de fetch diretamente
                        allElevationData = await fetchElevationData(selectionArea);

                        if (!allElevationData) {
                            addToLog('Erro: Não foi possível obter os dados de elevação.');
                            await Swal.fire('Erro', 'Não foi possível obter os dados de elevação.', 'error');
                            return;
                        }

                        addToLog('Todos os dados de elevação obtidos com sucesso.');
                    } catch (error) {
                        addToLog('Erro: Erro ao obter todos os dados de elevação:', error);
                        await Swal.fire('Erro', 'Ocorreu um erro ao obter os dados de elevação.', 'error');
                        return;
                    }


                    // Função para selecionar o melhor centróide baseado na cobertura máxima
                    async function selectBestCentroid(centroids, remainingIcons) {
                        let bestCentroid = null;
                        let maxCoverage = 0;
                        let elevationDataBest = null;

                        for (let centroid of centroids) {
                            // Obter os dados de elevação para o centróide a partir de allElevationData
                            const lat = centroid.lat;
                            const lon = centroid.lng;

                            // Definir uma área pequena ao redor do centróide para obter a elevação
                            const delta = 0.001; // Aproximadamente 111m
                            const minLat = lat - delta;
                            const maxLat = lat + delta;
                            const minLon = lon - delta;
                            const maxLon = lon + delta;

                            // Filtrar os dados de elevação que estão dentro da área do centróide
                            const epsilon = 0.01; // Margem de tolerância para buscar pontos próximos

                            const elevationData = allElevationData.filter(point => {
                                return point.lat >= (minLat - epsilon) && point.lat <= (maxLat + epsilon) &&
                                    point.lon >= (minLon - epsilon) && point.lon <= (maxLon + epsilon);
                            });


                            if (!Array.isArray(elevationData) || elevationData.length === 0) {
                                addToLog(`Erro: Dados de elevação inválidos ou vazios para centróide (${lat}, ${lon}).`);
                                continue; // Pular este centróide
                            }

                            // Selecionar o ponto com a maior elevação dentro da área do centróide
                            elevationData.sort((a, b) => b.elevation - a.elevation);
                            const highestPoint = elevationData[0];
                            const highestLatLng = L.latLng(highestPoint.lat, highestPoint.lon);

                            // Calcular quantos ícones ainda não cobertos estão dentro do raio de cobertura deste ponto
                            const iconsInCoverage = remainingIcons.filter(icon => {
                                const distance = calculateDistance(icon.latlng, highestLatLng);
                                return distance <= radiusMeters;
                            });

                            if (iconsInCoverage.length > maxCoverage) {
                                maxCoverage = iconsInCoverage.length;
                                bestCentroid = highestLatLng;
                                elevationDataBest = highestPoint;
                            }
                        }

                        if (bestCentroid) {
                            return {
                                centroid: bestCentroid,
                                coverageCount: maxCoverage,
                                elevation: elevationDataBest
                            };
                        } else {
                            return null;
                        }
                    }

                    // Função principal de cobertura otimizada
                    async function coverIconsOptimally(clusterIcons) {
                        // Filtrar os ícones que ainda não estão cobertos
                        let remainingIcons = clusterIcons.filter(icon => !coveredIcons.has(icon.marker._leaflet_id));

                        while (remainingIcons.length > 0) {
                            // Definir os limites do cluster para gerar centróides potenciais
                            const clusterLatLngs = remainingIcons.map(icon => [icon.latlng.lat, icon.latlng.lng]);
                            const minLat = Math.min(...clusterLatLngs.map(coord => coord[0]));
                            const maxLat = Math.max(...clusterLatLngs.map(coord => coord[0]));
                            const minLon = Math.min(...clusterLatLngs.map(coord => coord[1]));
                            const maxLon = Math.max(...clusterLatLngs.map(coord => coord[1]));

                            const clusterBounds = { minLat, maxLat, minLon, maxLon };

                            // Gerar centróides potenciais dentro dos limites do cluster
                            const potentialCentroids = generatePotentialCentroids(remainingIcons, clusterBounds, 1); // Grid de 1km

                            // Selecionar o melhor centróide baseado na cobertura máxima
                            const best = await selectBestCentroid(potentialCentroids, remainingIcons);

                            if (!best) {
                                addToLog('Erro: Não foi possível encontrar um centróide adequado para cobrir os ícones restantes.');
                                break; // Saia do loop para evitar um loop infinito
                            }

                            const { centroid, coverageCount, elevation } = best;

                            addToLog(`Melhor centróide selecionado: LatLng(${centroid.lat}, ${centroid.lng}) cobrindo ${coverageCount} ícones.`);

                            // Adicionar o ícone central no centróide
                            const centralMarker = L.marker([centroid.lat, centroid.lng], {
                                icon: L.icon({
                                    iconUrl: iconUrl,
                                    iconSize: [32, 32],
                                    iconAnchor: [16, 32],
                                    popupAnchor: [0, -32]
                                })
                            }).bindPopup(`Ícone Central<br>Elevação: ${elevation.elevation} metros`);

                            // Adicionar propriedades personalizadas
                            centralMarker.feature = {
                                type: "Feature",
                                properties: {
                                    folderName: "Sugestão de Planejamento",
                                    name: "Ícone Central",
                                    description: `Elevação: ${elevation.elevation} metros`,
                                    iconUrl: iconUrl,
                                    color: "#FF0000"
                                }
                            };

                            coverageLayer.addLayer(centralMarker);
                            addToLog(`Ícone central adicionado ao mapa em LatLng(${centroid.lat}, ${centroid.lng}).`);

                            // Desenhar o círculo de cobertura como um polígono
                            const polygonCoordinates = getCirclePolygon(centroid, radiusMeters);

                            const coveragePolygon = L.polygon(polygonCoordinates, {
                                color: '#FF0000',
                                fillColor: '#FF0000',
                                fillOpacity: 0.2,
                            }).bindPopup(`Cobertura de ${radiusKm} km`);

                            // Adicionar propriedades personalizadas ao polígono
                            coveragePolygon.feature = {
                                type: 'Feature',
                                properties: {
                                    shape: 'circle',
                                    center: [centroid.lat, centroid.lng],
                                    radius: radiusMeters,
                                    color: '#FF0000'
                                },
                                geometry: {
                                    type: 'Polygon',
                                    coordinates: [polygonCoordinates]
                                }
                            };

                            coverageLayer.addLayer(coveragePolygon);
                            coverageCircles.push(coveragePolygon); // Armazenar referência para verificação posterior
                            addToLog(`Círculo de cobertura desenhado como polígono em LatLng(${centroid.lat}, ${centroid.lng}).`);


                            // Marcar os ícones dentro da cobertura como cobertos
                            const iconsJustCovered = remainingIcons.filter(icon => {
                                const distance = calculateDistance(icon.latlng, centroid);
                                return distance <= radiusMeters;
                            });

                            iconsJustCovered.forEach(icon => {
                                coveredIcons.add(icon.marker._leaflet_id);
                                addToLog(`Ícone em LatLng(${icon.latlng.lat}, ${icon.latlng.lng}) está coberto pela cobertura central em LatLng(${centroid.lat}, ${centroid.lng}).`);
                            });

                            // Atualizar a lista de ícones restantes
                            remainingIcons = remainingIcons.filter(icon => !coveredIcons.has(icon.marker._leaflet_id));
                        }
                    }

                    // Iniciar a cobertura otimizada para cada cluster
                    for (let i = 0; i < clusters.length; i++) {
                        const cluster = clusters[i];

                        if (cluster.length === 0) {
                            console.warn(`Cluster ${i} está vazio. Pulando.`);
                            continue;
                        }

                        // Obter os ícones pertencentes a este cluster
                        const clusterIcons = cluster.map(index => iconsToCover[index]);

                        addToLog(`Processando Cluster ${i} com ${clusterIcons.length} ícones.`);

                        // Cobrir os ícones do cluster de forma otimizada
                        await coverIconsOptimally(clusterIcons);
                    }

                    addToLog('Tarefa concluída: Áreas de cobertura desenhadas.');
                }




















                document.getElementById('startPlanning').addEventListener('click', async function () {
                    const startButton = document.getElementById('startPlanning');

                    // Desabilita o botão para evitar novos cliques
                    startButton.disabled = true;

                    try {
                        await startPlanning(); // Aguarda a conclusão da sequência de tarefas
                    } catch (error) {
                        console.error('Erro na execução da sequência de tarefas:', error);
                    } finally {
                        // Reabilita o botão após a conclusão
                        startButton.disabled = false;
                    }
                });








                // Função para deletar uma sequência de tarefas
                async function deleteTaskSequence() {
                    // Passo 1: Solicitar a lista de sequências para deletar
                    const formDataLoad = new FormData();
                    formDataLoad.append('action', 'load');

                    try {
                        const responseLoad = await fetch('tasks.php', {
                            method: 'POST',
                            body: formDataLoad
                        });
                        const resultLoad = await responseLoad.json();

                        if (!resultLoad.success) {
                            await Swal.fire('Erro', resultLoad.error || 'Falha ao carregar as sequências.', 'error');
                            console.error('Falha ao carregar as sequências:', resultLoad.error);
                            return;
                        }

                        const sequences = resultLoad.sequences;

                        if (sequences.length === 0) {
                            await Swal.fire('Aviso', 'Não há sequências para deletar.', 'info');
                            return;
                        }

                        // Passo 2: Selecionar a sequência a deletar
                        const { value: selectedSequence } = await Swal.fire({
                            title: 'Deletar Sequência',
                            input: 'select',
                            inputOptions: sequences.reduce((options, name) => {
                                options[name] = name;
                                return options;
                            }, {}),
                            inputPlaceholder: 'Selecione uma sequência',
                            showCancelButton: true,
                            inputValidator: (value) => {
                                if (!value) {
                                    return 'Por favor, selecione uma sequência para deletar.';
                                }
                            }
                        });

                        if (!selectedSequence) {
                            // Usuário cancelou a ação
                            return;
                        }

                        // Passo 3: Solicitar a senha para deletar
                        const { value: deletePassword } = await Swal.fire({
                            title: 'Senha',
                            input: 'password',
                            inputLabel: 'Digite a senha para deletar a sequência',
                            inputPlaceholder: 'Senha',
                            showCancelButton: true,
                            inputValidator: (value) => {
                                if (!value) {
                                    return 'Por favor, insira a senha.';
                                }
                            }
                        });

                        if (!deletePassword) {
                            // Usuário cancelou a ação
                            return;
                        }

                        // Passo 4: Confirmar a deleção
                        const { isConfirmed } = await Swal.fire({
                            title: 'Confirmar Deleção',
                            text: `Tem certeza de que deseja deletar a sequência "${selectedSequence}"? Esta ação não pode ser desfeita.`,
                            icon: 'warning',
                            showCancelButton: true,
                            confirmButtonText: 'Sim, deletar',
                            cancelButtonText: 'Cancelar'
                        });

                        if (!isConfirmed) {
                            // Usuário cancelou a deleção
                            return;
                        }

                        // Passo 5: Enviar a requisição para deletar a sequência
                        const formDataDelete = new FormData();
                        formDataDelete.append('action', 'delete_sequence');
                        formDataDelete.append('name', selectedSequence);
                        formDataDelete.append('password', deletePassword);

                        const responseDelete = await fetch('tasks.php', {
                            method: 'POST',
                            body: formDataDelete
                        });

                        const resultDelete = await responseDelete.json();

                        if (resultDelete.success) {
                            await Swal.fire('Sucesso', `Sequência "${selectedSequence}" deletada com sucesso.`, 'success');
                            // Atualizar a lista de tarefas no modal
                            taskSequence = taskSequence.filter(task => task.name !== selectedSequence);
                            defineTasksInSingleScreen();
                        } else {
                            await Swal.fire('Erro', resultDelete.error || 'Falha ao deletar a sequência.', 'error');
                            console.error('Falha ao deletar a sequência:', resultDelete.error);
                        }

                    } catch (error) {
                        console.error('Erro ao deletar a sequência:', error);
                        await Swal.fire('Erro', 'Erro ao deletar a sequência.', 'error');
                    }
                }


                // Função para salvar a sequência de tarefas
                async function saveTaskSequence() {
                    // Passo 1: Solicitar Nome da Sequência
                    const { value: sequenceName } = await Swal.fire({
                        title: 'Salvar Sequência',
                        input: 'text',
                        inputLabel: 'Nome da Sequência',
                        inputPlaceholder: 'Digite o nome da sequência',
                        showCancelButton: true,
                        inputValidator: (value) => {
                            if (!value) {
                                return 'Por favor, insira um nome para a sequência.';
                            }
                        }
                    });

                    if (!sequenceName) {
                        // Se o usuário cancelar ou não fornecer um nome, não prosseguir
                        return;
                    }

                    // Passo 2: Solicitar Senha
                    const { value: password } = await Swal.fire({
                        title: 'Senha',
                        input: 'password',
                        inputLabel: 'Digite a senha para salvar a sequência',
                        inputPlaceholder: 'Senha',
                        showCancelButton: true,
                        inputValidator: (value) => {
                            if (!value) {
                                return 'Por favor, insira a senha.';
                            }
                        }
                    });

                    if (!password) {
                        // Se o usuário cancelar a inserção de senha, não prosseguir
                        return;
                    }

                    // Passo 2.5: Solicitar Descrição da Sequência
                    const { value: description } = await Swal.fire({
                        title: 'Descrição da Sequência',
                        input: 'textarea',
                        inputLabel: 'Descrição',
                        inputPlaceholder: 'Digite uma descrição para o seu planejamento (até um parágrafo)...',
                        inputAttributes: {
                            'aria-label': 'Digite uma descrição para o seu planejamento'
                        },
                        showCancelButton: true,
                        inputValidator: (value) => {
                            if (!value) {
                                return 'Por favor, insira uma descrição para a sequência.';
                            }
                            if (value.length > 500) { // Limite de 500 caracteres (ajuste conforme necessário)
                                return 'A descrição não deve exceder 500 caracteres.';
                            }
                        }
                    });

                    if (!description) {
                        // Se o usuário cancelar ou não fornecer uma descrição, não prosseguir
                        return;
                    }


                    // Passo 3: Verificar se a sequência já existe
                    const formDataCheck = new FormData();
                    formDataCheck.append('action', 'check_sequence');
                    formDataCheck.append('name', sequenceName);

                    try {
                        const responseCheck = await fetch('tasks.php', {
                            method: 'POST',
                            body: formDataCheck
                        });
                        const resultCheck = await responseCheck.json();

                        let overwritePassword = '';

                        // Passo 4: Salvar a sequência
                        const formData = new FormData();
                        formData.append('action', 'save');
                        formData.append('name', sequenceName);
                        formData.append('description', description);
                        formData.append('sequence', JSON.stringify(taskSequence));
                        formData.append('password', overwritePassword || password);

                        const response = await fetch('tasks.php', {
                            method: 'POST',
                            body: formData
                        });
                        const result = await response.json();

                        if (result.success) {
                            await Swal.fire('Sucesso', `Sequência salva com sucesso: ${sequenceName}`, 'success').then(() => {
                                // Reabrir o modal principal após salvar
                                defineTasksInSingleScreen();
                            });
                        } else {
                            await Swal.fire('Erro', result.error || 'Falha ao salvar a sequência', 'error');
                            console.error('Falha ao salvar a sequência:', result.error);
                        }
                    } catch (error) {
                        console.error('Erro ao salvar a sequência:', error);
                        await Swal.fire('Erro', 'Erro ao salvar a sequência', 'error');
                    }
                }


                async function loadTaskSequences() {
                    // Solicita a lista de sequências salvas
                    const formData = new FormData();
                    formData.append('action', 'load');

                    try {
                        const response = await fetch('tasks.php', {
                            method: 'POST',
                            body: formData
                        });
                        const result = await response.json();

                        if (result.success) {
                            const sequences = result.sequences;

                            if (sequences.length === 0) {
                                await Swal.fire('Aviso', 'Não há sequências salvas.', 'info');
                                return;
                            }

                            const { value: selectedSequence } = await Swal.fire({
                                title: 'Carregar Sequência',
                                input: 'select',
                                inputOptions: sequences.reduce((options, name) => {
                                    options[name] = name;
                                    return options;
                                }, {}),
                                inputPlaceholder: 'Selecione uma sequência',
                                showCancelButton: true
                            });

                            if (selectedSequence) {
                                // Obter os detalhes da sequência selecionada
                                await loadTaskSequenceDetails(selectedSequence);
                            }

                        } else {
                            Swal.fire('Erro', result.error || 'Falha ao carregar as sequências', 'error');
                            console.error('Falha ao carregar as sequências:', result.error);
                        }
                    } catch (error) {
                        console.error('Erro ao carregar as sequências:', error);
                        Swal.fire('Erro', 'Erro ao carregar as sequências', 'error');
                    }
                }

                async function loadTaskSequenceDetails(sequenceName) {
                    const formData = new FormData();
                    formData.append('action', 'get_sequence');
                    formData.append('name', sequenceName);

                    try {
                        const response = await fetch('tasks.php', {
                            method: 'POST',
                            body: formData
                        });
                        const result = await response.json();

                        if (result.success) {
                            taskSequence = result.sequence;
                            const description = result.description || 'Nenhuma descrição fornecida.';

                            await Swal.fire({
                                title: `Sequência: ${sequenceName}`,
                                html: `<p><strong>Descrição:</strong> ${description}</p>`,
                                icon: 'info'
                            });

                            // Por exemplo, chamar defineTasksInSingleScreen() para exibir a sequência carregada
                            defineTasksInSingleScreen();

                        } else {
                            Swal.fire('Erro', result.error || 'Falha ao carregar a sequência', 'error');
                            console.error('Falha ao carregar a sequência:', result.error);
                        }
                    } catch (error) {
                        console.error('Erro ao carregar a sequência:', error);
                        Swal.fire('Erro', 'Erro ao carregar a sequência', 'error');
                    }
                }




                var selectedLayers = []; // Agora é um array para armazenar múltiplos usuários
                var intervalId;     // Variável para armazenar o intervalo de atualização
                var layerRegistry = {}; // Para garantir que as camadas estejam registradas corretamente
                var previousGeoJsonData = {}; // Para armazenar o estado anterior da camada carregada

                // Função para gerar um hash de um objeto GeoJSON
                function generateGeoJsonHash(geoJsonObject) {
                    return JSON.stringify(geoJsonObject);  // Pode usar uma função de hash mais sofisticada, se necessário
                }

                async function reloadLayer() {
                    if (!selectedLayers || selectedLayers.length === 0) {
                        Swal.fire('Nenhum usuário fornecido!', 'Por favor, insira pelo menos um nome de usuário para carregar a camada.', 'warning');
                        return;
                    }

                    for (const layerName of selectedLayers) {
                        try {
                            const response = await fetch("/carregar.php", {
                                method: "POST",
                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                body: `usuario=${encodeURIComponent(layerName)}`
                            });

                            if (!response.ok) {
                                const errorMessage = await response.text();
                                Swal.fire('Erro no servidor', `Erro ao carregar o usuário ${layerName}: ${errorMessage}`, 'error');
                                continue; // Pula para o próximo usuário
                            }

                            const geoJsonData = await response.json();

                            if (!isValidGeoJson(geoJsonData)) {
                                const errorMessage = typeof geoJsonData === 'string' ? geoJsonData : 'A camada carregada não é um GeoJSON válido.';
                                Swal.fire('Erro', `Erro no usuário ${layerName}: ${errorMessage}`, 'error');
                                continue; // Pula para o próximo usuário
                            }

                            const currentGeoJsonHash = generateGeoJsonHash(geoJsonData);

                            if (currentGeoJsonHash !== previousGeoJsonData[layerName]) {
                                // Se houver mudanças, remover a camada anterior
                                if (layerRegistry[layerName]) {
                                    map.removeLayer(layerRegistry[layerName]);
                                    layerControl.removeLayer(layerRegistry[layerName]); // Remove a camada do controle de camadas
                                    delete layerRegistry[layerName];  // Remove do registro
                                }

                                // Processar os dados do GeoJSON e adicionar ao mapa como camada não-editável
                                const newLayer = L.geoJson(null);

                                L.geoJson(geoJsonData, {
                                    onEachFeature: function (feature, layer) {
                                        if (feature.geometry.type === 'Point' && Object.keys(feature.properties).length === 0) {
                                            var emptyIcon = L.divIcon({ html: '', className: 'empty-icon', iconSize: [0, 0] });
                                            layer.setIcon(emptyIcon);
                                            newLayer.addLayer(layer);
                                        } else if (feature.geometry.type === 'Point' && feature.properties.shape === 'circle') {
                                            var newCircle = L.circle([feature.properties.center[0], feature.properties.center[1]], {
                                                color: feature.properties.color,
                                                fillColor: feature.properties.color,
                                                fillOpacity: 0.5,
                                                radius: feature.properties.radius
                                            });
                                            newLayer.addLayer(newCircle);
                                        } else if (feature.properties.text && feature.geometry.type === 'Point' && !feature.properties.iconUrl) {
                                            var customIcon = L.divIcon({
                                                className: 'custom-text-label',
                                                html: feature.properties.text,
                                                iconSize: [100, 30],
                                                iconAnchor: [15, 15]
                                            });
                                            layer.setIcon(customIcon);
                                            newLayer.addLayer(layer);
                                        } else if (feature.geometry.type === 'Point' && feature.properties.iconUrl) {
                                            var customIcon = L.icon({
                                                iconUrl: feature.properties.iconUrl,
                                                iconSize: [40, 40],
                                                iconAnchor: [15, 15]
                                            });
                                            layer.setIcon(customIcon);
                                            newLayer.addLayer(layer);
                                        } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'Polygon') {
                                            layer.setStyle({ color: feature.properties.color });
                                            newLayer.addLayer(layer);
                                        }
                                    }
                                });

                                // Atualiza o estado anterior com o novo hash do GeoJSON
                                previousGeoJsonData[layerName] = currentGeoJsonHash;

                                // Adiciona a nova camada ao controle de camadas existente
                                addNewOverlayLayer(layerName, newLayer);

                                // Registra a camada no registry e adiciona ao mapa
                                layerRegistry[layerName] = newLayer;
                                map.addLayer(newLayer);

                                // Exibir popup informando que a camada foi atualizada
                                Swal.fire('Camada Atualizada!', `A camada "${layerName}" foi atualizada com sucesso.`, 'info');
                            }

                        } catch (error) {
                            console.error(`Erro ao atualizar a camada para o usuário ${layerName}:`, error);
                        }
                    }
                }


                // Função para verificar se o objeto é um GeoJSON válido
                function isValidGeoJson(geoJsonObject) {
                    return geoJsonObject && typeof geoJsonObject === 'object' &&
                        (geoJsonObject.type === 'Feature' || geoJsonObject.type === 'FeatureCollection') &&
                        (geoJsonObject.type === 'FeatureCollection' ? geoJsonObject.features && Array.isArray(geoJsonObject.features) : true);
                }

                // Função para solicitar os nomes dos usuários e configurar o tempo de atualização
                function promptUserAndUpdate() {
                    Swal.fire({
                        title: 'Nome(s) de usuário(s)',
                        input: 'text',
                        inputLabel: 'Insira o nome do usuário. Caso existam mais de um, separe os nomes com vírgula. Exemplo: "sca,ge".',
                        inputPlaceholder: 'teste,teste2',
                        showCancelButton: true,
                        confirmButtonText: 'Carregar Camada(s)',
                        preConfirm: (usernameInput) => {
                            if (!usernameInput) {
                                Swal.showValidationMessage('Por favor, insira pelo menos um nome de usuário válido.');
                                return false;
                            }
                            const usernames = usernameInput.split(',').map(name => name.trim()).filter(name => name !== '');
                            if (usernames.length === 0) {
                                Swal.showValidationMessage('Por favor, insira pelo menos um nome de usuário válido.');
                                return false;
                            }
                            return usernames;
                        }
                    }).then((result) => {
                        if (result.isConfirmed) {
                            selectedLayers = result.value;

                            // Solicitar o intervalo de atualização
                            Swal.fire({
                                title: 'Configurar Intervalo de Atualização',
                                input: 'number',
                                inputLabel: 'Intervalo em segundos:',
                                inputPlaceholder: 'Digite o número de segundos',
                                showCancelButton: true,
                                confirmButtonText: 'Iniciar',
                                cancelButtonText: 'Cancelar',
                                preConfirm: (value) => {
                                    const seconds = parseInt(value, 10);
                                    if (isNaN(seconds) || seconds <= 0) {
                                        Swal.showValidationMessage('Por favor, insira um valor válido.');
                                        return false;
                                    }
                                    startAutoReload(seconds);  // Iniciar a atualização automática com o intervalo fornecido
                                }
                            });
                        }
                    });
                }


                // Função para configurar o intervalo de atualização
                function startAutoReload(seconds) {
                    if (intervalId) {
                        clearInterval(intervalId);  // Limpa o intervalo anterior, se existir
                    }

                    intervalId = setInterval(reloadLayer, seconds * 1000);  // Define o intervalo de atualização
                    document.getElementById('startUpdateButton').style.color = 'green';  // Altera a cor do ícone
                }

                // Event listener para o botão de iniciar a atualização periódica
                document.getElementById('startUpdateButton').addEventListener('click', promptUserAndUpdate);








 document.getElementById('addLayerButton').addEventListener('click', function() {
                    getSigsData().then(sigsData => {
                        var inputOptions = {};
                        var nomeToURL = {};
                        sigsData.forEach(item => {
                            inputOptions[item.Nome] = item.Nome;
                            nomeToURL[item.Nome] = item.URL;
                        });

                        // Ordena os SIGs em ordem alfabética
                        var sigNames = Object.keys(inputOptions).sort(function(a, b) {
                            return a.localeCompare(b, 'pt-BR', { sensitivity: 'base' });
                        });

                        var sortedInputOptions = {};
                        sigNames.forEach(nome => {
                            sortedInputOptions[nome] = inputOptions[nome];
                        });

                        Swal.fire({
                            title: 'Selecione o SIG',
                            input: 'select',
                            inputOptions: sortedInputOptions,
                            inputPlaceholder: 'Selecione um SIG',
                            showCancelButton: true,
                        }).then((result) => {
                            if (result.isConfirmed) {
                                var selectedNome = result.value;
                                var selectedURL = nomeToURL[selectedNome];

                                getWMSLayers(selectedURL).then(layers => {
                                    var inputOptions = {};
                                    var layerOptions = {};

                                    layers.forEach(layer => {
                                        layerOptions[layer.Name] = layer.Title || layer.Name;
                                    });

                                    // Cria um array de opções ordenadas
                                    var optionsArray = layers.map(layer => ({
                                        value: layer.Name,
                                        text: layer.Title || layer.Name
                                    }));

                                    // Constrói o objeto de opções
                                    optionsArray.forEach(option => {
                                        inputOptions[option.value] = option.text;
                                    });

                                    Swal.fire({
                                        title: 'Selecione a Camada',
                                        input: 'select',
                                        inputOptions: inputOptions,
                                        inputPlaceholder: 'Selecione uma Camada',
                                        showCancelButton: true,
                                    }).then((layerResult) => {
                                        if (layerResult.isConfirmed) {
                                            var selectedLayerName = layerResult.value;
                                            var selectedLayerTitle = layerOptions[selectedLayerName];

                                            addWMSLayerToMap(selectedURL, selectedLayerName, selectedLayerTitle);
                                        }
                                    });
                                });
                            }
                        });
                    });
 });

                



                document.getElementById('removeLayerButton').addEventListener('click', function() {
                    var layerOptions = {};
                    Object.keys(layerRegistry).forEach(layerName => {
                        layerOptions[layerName] = layerName;
                    });

                    if (Object.keys(layerOptions).length === 0) {
                        Swal.fire('Aviso', 'Não há camadas para remover.', 'info');
                        return;
                    }

                    Swal.fire({
                        title: 'Selecione a Camada para Remover',
                        input: 'select',
                        inputOptions: layerOptions,
                        inputPlaceholder: 'Selecione uma Camada',
                        showCancelButton: true,
                    }).then((result) => {
                        if (result.isConfirmed) {
                            var selectedLayerName = result.value;
                            var layer = layerRegistry[selectedLayerName];
                            if (layer) {
                                map.removeLayer(layer); // Remove a camada do mapa
                                layerControl.removeLayer(layer); // Remove a camada do controle de camadas
                                delete layerRegistry[selectedLayerName]; // Remove a camada do registro
                            }
                        }
                    });
                });


                map.on('click', function(e) {
                    var latlng = e.latlng;
                    getFeatureInfoAtPoint(latlng);
                });

                function getFeatureInfoAtPoint(latlng) {
                    // Definir as camadas a serem ignoradas
                    const excludedLayers = [
                        layerRegistry["OpenTopo"],
                        layerRegistry["Google Satellite"],
                        layerRegistry["Infraestruturas"],
                        layerRegistry["Quadrículas - UTM"],
                        layerRegistry["BDGEx - CTM50"],
                        layerRegistry["Sugestão de Planejamento"]
                    ];

                    // Obter as camadas WMS ativas, excluindo as camadas ignoradas
                    var activeWMSLayers = [];
                    map.eachLayer(function(layer) {
                        // Verifica se a camada é uma WMS, está ativa no mapa e não está na lista de exclusão
                        if (layer instanceof L.TileLayer.WMS && map.hasLayer(layer) && !excludedLayers.includes(layer)) {
                            activeWMSLayers.push(layer);
                        }
                    });

                    if (activeWMSLayers.length === 0) {
                        return; // Nenhuma camada WMS ativa que não está na lista de exclusão
                    }

                    activeWMSLayers.forEach(function(layer) {
                        var wmsURL = layer._url;
                        var layerNames = layer.wmsParams.layers;

                        var point = map.latLngToContainerPoint(latlng, map.getZoom());
                        var size = map.getSize();

                        var params = {
                            service: 'WMS',
                            request: 'GetFeatureInfo',
                            srs: 'EPSG:4326',
                            styles: '',
                            transparent: true,
                            version: '1.1.1',
                            format: 'image/png',
                            bbox: map.getBounds().toBBoxString(),
                            height: size.y,
                            width: size.x,
                            layers: layerNames,
                            query_layers: layerNames,
                            info_format: 'text/html', // ou 'applicationjson', dependendo do servidor
                            x: Math.round(point.x),
                            y: Math.round(point.y)
                        };

                        // Constrói a string de parâmetros
                        var paramsString = L.Util.getParamString(params, null, true); // O segundo parâmetro é 'null', e o terceiro 'true' para upperCase

                        // Constrói a URL completa do GetFeatureInfo
                        var fullURL = wmsURL + paramsString;

                        // Codifica a URL completa e a passa para o proxy.php
                        var proxyURL = '/proxy.php?url=' + encodeURIComponent(fullURL);

                        fetch(proxyURL)
                            .then(function(response) {
                            return response.text();
                        })
                            .then(function(data) {
                            const mensagemIgnorar = "received wms getfeatureinfo request for unqueryable".toLowerCase();
                            if (data && !data.trim().toLowerCase().includes(mensagemIgnorar)) {
                                // Exibir o popup no mapa com opções personalizadas
                                L.popup({
                                    maxWidth: 500, // Define a largura máxima do popup
                                    minWidth: 200, // Define a largura mínima do popup
                                    closeButton: true, // Exibe o botão de fechar
                                    autoPan: true, // Pan automaticamente para exibir o popup completamente
                                    className: 'custom-popup' // Adiciona uma classe personalizada para o popup
                                })
                                    .setLatLng(latlng)
                                    .setContent('<div class="popup-content">' + data + '</div>')
                                    .openOn(map);
                            }
                        })
                            .catch(function(error) {
                            console.error('Erro ao obter GetFeatureInfo:', error);
                        });

                    });
                }



                document.getElementById('helpButton').addEventListener('click', function() {
                    Swal.fire({
                        title: 'Ajuda - Guia de Botões',
                        html: `
<div id="helpTabs" style="display: flex; justify-content: center; margin-bottom: 10px;">
<button class="swal2-styled" id="btnGeneral" style="margin: 0 10px;">Geral</button>
<button class="swal2-styled" id="btnDraw" style="margin: 0 10px;">Desenho</button>
<button class="swal2-styled" id="btnLayers" style="margin: 0 10px;">Camadas</button>
<button class="swal2-styled" id="btnLeafletControls" style="margin: 0 10px;">Leaflet Controls</button>
            </div>
<div id="generalHelp" class="help-section">
<p><i class="fas fa-file-export"></i> <b>Exportar para KMZ:</b> Exporte o conteúdo do mapa para um arquivo KMZ.</p>
<p><i class="fas fa-file-import"></i> <b>Importar KMZ:</b> Importe arquivos KMZ para visualização no mapa.</p>
<p><i class="fas fa-map-marker-alt"></i> <b>Localização:</b> Mostra/esconde sua localização atual.</p>
<p><i class="fas fa-save"></i> <b>Salvar Desenhos:</b> Salve os desenhos feitos no mapa.</p>
<p><i class="fas fa-download"></i> <b>Carregar Desenhos:</b> Carregue desenhos salvos anteriormente.</p>
<p><i class="fas fa-images"></i> <b>Carregar Imagens:</b> Carregue imagens no mapa como camadas de sobreposição.</p>
<p><i class="fas fa-share-alt"></i> <b>Compartilhar Link:</b> Gere e compartilhe um link com as camadas atuais.</p>
<p><i class="fas fa-network-wired"></i> <b>Planejamento Automático:</b> Inicia o processo de planejamento automático no mapa.</p>
            </div>
<div id="drawHelp" class="help-section" style="display:none;">
<p><i class="fas fa-minus"></i> <b>Desenhar Linha:</b> Ferramenta para desenhar linhas no mapa.</p>
<p><i class="fas fa-draw-polygon"></i> <b>Desenhar Polígono:</b> Ferramenta para desenhar polígonos no mapa.</p>
<p><i class="fas fa-square"></i> <b>Desenhar Quadrado:</b> Ferramenta para desenhar quadrados no mapa.</p>
<p><i class="fas fa-circle"></i> <b>Desenhar Círculo:</b> Ferramenta para desenhar círculos no mapa.</p>
<p><i class="fas fa-map-marker-alt"></i> <b>Adicionar Marcador:</b> Ferramenta para colocar um marcador no mapa.</p>
<p><i class="fas fa-circle-notch"></i> <b>Linha de alturas:</b> Ferramenta para fazer um perfil topográfico.</p>
<p><i class="fas fa-pencil-alt"></i> <b>Editar Elementos:</b> Ferramenta para mover elementos desenhados no mapa.</p>
<p><i class="fas fa-trash"></i> <b>Excluir Elementos:</b> Ferramenta para excluir elementos desenhados no mapa.</p>
            </div>

<div id="layersHelp" class="help-section" style="display:none;">
<p><i class="fas fa-plus"></i> <b>Adicionar Camada:</b> Adicione uma camada ao mapa.</p>
<p><i class="fas fa-minus"></i> <b>Remover Camada:</b> Remova uma camada do mapa.</p>
<p><i class="fas fa-save"></i> <b>Salvar Sugestão de Planejamento:</b> Salve a camada de sugestão de planejamento.</p>
<p><i class="fas fa-sync-alt"></i> <b>Inserir Camada Atualizável:</b> Insira uma camada que será atualizada automaticamente.</p>
<p><i class="fas fa-layer-group"></i> <b>Controles de Camadas:</b> Use os controles de camadas à direita para ativar/desativar camadas no mapa.</p>
            </div>
<div id="leafletControlsHelp" class="help-section" style="display:none;">
<p><i class="fas fa-ruler"></i> <b>Medir Distância/Área:</b> Ferramenta de medição de distâncias e áreas.</p>
<p><i class="fas fa-print"></i> <b>Imprimir Mapa:</b> Imprime o mapa atual com a escala selecionada.</p>
<p><i class="fas fa-search-plus"></i> <b>Zoom In:</b> Aumenta o zoom no mapa.</p>
<p><i class="fas fa-search-minus"></i> <b>Zoom Out:</b> Diminui o zoom no mapa.</p>
            </div>
`,
                        confirmButtonText: 'Fechar',
                        didOpen: () => {
                            // Função para trocar as abas ao clicar
                            document.getElementById('btnGeneral').addEventListener('click', function() {
                                toggleSections('generalHelp');
                            });
                            document.getElementById('btnDraw').addEventListener('click', function() {
                                toggleSections('drawHelp');
                            });
                            document.getElementById('btnLayers').addEventListener('click', function() {
                                toggleSections('layersHelp');
                            });
                            document.getElementById('btnLeafletControls').addEventListener('click', function() {
                                toggleSections('leafletControlsHelp');
                            });
                        }
                    });

                    // Função para mostrar/esconder seções de ajuda
                    function toggleSections(sectionId) {
                        const sections = document.querySelectorAll('.help-section');
                        sections.forEach(section => section.style.display = 'none');
                        document.getElementById(sectionId).style.display = 'block';
                    }
                });

                document.getElementById('savePlanningButton').addEventListener('click', function() {
                    // Utiliza o SweetAlert2 para solicitar o usuário e senha
                    Swal.fire({
                        title: 'Insira suas credenciais',
                        html: `
<input type="text" id="swal-input-usuario" class="swal2-input" placeholder="Usuário">
<input type="password" id="swal-input-senha" class="swal2-input" placeholder="Senha">
`,
                        focusConfirm: false,
                        preConfirm: () => {
                            const usuario = document.getElementById('swal-input-usuario').value;
                            const senha = document.getElementById('swal-input-senha').value;
                            if (!usuario || !senha) {
                                Swal.showValidationMessage('Usuário e senha são necessários!');
                                return false;
                            }
                            return { usuario: usuario, senha: senha };
                        }
                    }).then((result) => {
                        if (result.isConfirmed) {
                            const { usuario, senha } = result.value;

                            // Gera o GeoJSON da camada "Sugestão de Planejamento"
                            const planejamentoData = planejamentoLayer.toGeoJSON();

                            // Itera por cada feature para incluir propriedades personalizadas
                            planejamentoData.features.forEach(function(feature) {
                                // Obtém o ID único da feature no Leaflet
                                const layerId = feature.properties._leaflet_id;
                                const layer = planejamentoLayer.getLayer(layerId);

                                if (layer && layer.options) {
                                    // Se a camada possui um ícone (marcador)
                                    if (layer.options.icon && layer.options.icon.options.iconUrl) {
                                        feature.properties.iconUrl = layer.options.icon.options.iconUrl;
                                        // Adicione outras propriedades do ícone, se necessário
                                    }
                                    // Se a camada possui uma cor (formas como polígonos ou linhas)
                                    if (layer.options.color) {
                                        feature.properties.color = layer.options.color;
                                    }
                                }
                            });

                            // Obtém a URL completa da janela atual
                            const urlCompleta = window.location.href;

                            // Extrai o diretório a partir da URL completa usando expressão regular
                            const padraoDiretorio = /https:\/\/methodux\.online\/(.*?)\//;
                            const resultado = padraoDiretorio.exec(urlCompleta);

                            // A variável 'diretorio' conterá o diretório atual, ou uma string vazia se não encontrado
                            const diretorio = resultado ? resultado[1] : '';

                            // Prepara os dados a serem enviados
                            const data = {
                                usuario: usuario,
                                senha: senha,
                                link: diretorio, // Diretório a ser usado na requisição
                                leaflet: JSON.stringify(planejamentoData) // Converte os dados da camada para uma string JSON
                            };

                            // Envio dos dados via AJAX usando jQuery
                            $.ajax({
                                type: "POST",
                                url: "/salvar.php", // Substitua pelo caminho correto para sua página PHP
                                data: data,
                                success: function(response) {
                                    Swal.fire('Sucesso!', 'Sugestão de Planejamento salva com sucesso!', 'success');
                                },
                                error: function(xhr, status, error) {
                                    console.error("Erro ao salvar a Sugestão de Planejamento:", error);
                                    Swal.fire('Erro!', 'Não foi possível salvar a Sugestão de Planejamento.', 'error');
                                }
                            });
                        }
                    });
                });


        </script>
    </body>
</html>